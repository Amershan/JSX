(function(){var global = this;function debug(){return debug};function require(p, parent){ var path = require.resolve(p) , mod = require.modules[path]; if (!mod) throw new Error('failed to require "' + p + '" from ' + parent); if (!mod.exports) { mod.exports = {}; mod.call(mod.exports, mod, mod.exports, require.relative(path), global); } return mod.exports;}require.modules = {};require.resolve = function(path){ var orig = path , reg = path + '.js' , index = path + '/index.js'; return require.modules[reg] && reg || require.modules[index] && index || orig;};require.register = function(path, fn){ require.modules[path] = fn;};require.relative = function(parent) { return function(p){ if ('debug' == p) return debug; if ('.' != p.charAt(0)) return require(p); var path = parent.split('/') , segs = p.split('/'); path.pop(); for (var i = 0; i < segs.length; i++) { var seg = segs[i]; if ('..' == seg) path.pop(); else if ('.' != seg) path.push(seg); } return require(path.join('/'), parent); };};require.register("_builtins.js", function(module, exports, require, global){
// THIS FILE IS AUTOMATICALLY GENERATED.
// DO NOT EDIT IT!
"use strict";

var BuiltinClassContent = module.exports = {
	"lib/built-in/Boolean.jsx":
		"native final class Boolean {\n"+
		"\n"+
		"	// 15.6.2\n"+
		"	function initialize();\n"+
		"	function initialize(value : boolean);\n"+
		"\n"+
		"	// 15.6.4\n"+
		"	function toString() : String;\n"+
		"	function valueOf() : boolean;\n"+
		"}\n"+
		"\n"+
		"// vim: set noexpandtab:\n",
	"lib/built-in/Number.jsx":
		"native final class Number {\n"+
		"\n"+
		"	// 15.7.2\n"+
		"	function initialize();\n"+
		"	function initialize(value : number);\n"+
		"\n"+
		"	// 15.7.3\n"+
		"	static var MAX_VALUE : number;\n"+
		"	static var MIN_VALUE : number;\n"+
		"	static var NaN : number;\n"+
		"	static var NEGATIVE_INFINITY : number;\n"+
		"	static var POSITIVE_INFINITY : number;\n"+
		"	\n"+
		"	// 15.7.4\n"+
		"	function toString() : String;\n"+
		"	function toString(radix : int) : String;\n"+
		"	function toLocaleString() : String;\n"+
		"	function valueOf() : number;\n"+
		"	function toFixed(fractionDigits : int) : String;\n"+
		"	function toExpotential(fractionDigits : int) : String;\n"+
		"	function toPrecision(precision : int) : String;\n"+
		"}\n"+
		"\n"+
		"// vim: set noexpandtab:\n",
	"lib/built-in/String.jsx":
		"native final class String {\n"+
		"\n"+
		"	// 15.5.2\n"+
		"	function initialize();\n"+
		"	function initialize(s : String);\n"+
		"\n"+
		"	// 15.5.3\n"+
		"	static function fromCharCode(char0 : int) : String; // FIXME support vararg\n"+
		"\n"+
		"	// 15.5.4\n"+
		"	function toString() : String;\n"+
		"	function valueOf() : String;\n"+
		"	function charAt(pos : int) : String;\n"+
		"	function charCodeAt(pos : int) : int;\n"+
		"	function concat(string1 : String) : String; // FIXME support vararg\n"+
		"	function indexOf(searchString : String) : int;\n"+
		"	function indexOf(searchString : String, position : int) : int;\n"+
		"	function lastIndexOf(searchString : String) : int;\n"+
		"	function lastIndexOf(searchString : String, position : int) : int;\n"+
		"	// FIXME localeCompare?\n"+
		"	// FIXME function match(regexp : RegExp) : String [];\n"+
		"	function replace(searchValue : String, replaceValue : String) : String;\n"+
		"	// FIXME function replace(searchValue : String, replaceValue : function) : String;\n"+
		"	// FIXME function replace(searchValue : RegExp, replaceValue : String) : String;\n"+
		"	// FIXME function replace(searchValue : RegExp, replaceValue : function) : String;\n"+
		"	function search(searchValue : String) : int;\n"+
		"	// FIXME function search(searchValue : RegExp) : int;\n"+
		"	function slice(start : int, end : int) : String;\n"+
		"	function split(separator : String) : String [];\n"+
		"	function split(separator : String, limit : int) : String [];\n"+
		"	// FIXME function split(separator : RegExp) : String [];\n"+
		"	// FIXME function split(separator : RegExp, limit : int) : String [];\n"+
		"	function substring(start : int, end : int) : String;\n"+
		"	function toLowerCase() : String;\n"+
		"	function toLocaleLowerCase() : String;\n"+
		"	function toUpperCase() : String;\n"+
		"	function toLocaleUpperCase() : String;\n"+
		"\n"+
		"	// 15.5.5\n"+
		"	var length : int;\n"+
		"}\n"+
		"\n"+
		"// vim: set noexpandtab:\n"
}; // end of BuiltinClassContent

});require.register("Class.js", function(module, exports, require, global){
"use strict";

var Class = module.exports = function () {
};

Class.extend = function (properties) {
	var ctor = properties.initialize;
	if (typeof ctor === "undefined") {
		var superCtor = this.prototype.initialize;
		ctor = properties.initialize = function () {
			superCtor.call(this);
		};
	}
	function tmp() {};
	tmp.prototype = this.prototype;
	ctor.prototype = new tmp();
	ctor.extend = Class.extend;
	// assign properties
	for (var k in properties) {
		if (k.charAt(0) == '$') {
			ctor[k.substring(1)] = properties[k];
		} else {
			ctor.prototype[k] = properties[k];
		}
	}
	if (typeof ctor.initialize === "function") {
		ctor.initialize();
	}
	return ctor;
};

Class.prototype.initialize = function () {
};

Class.$import = function (name) {
	return "var __module = require(\"" + name + "\");\n"
		+ "for (var n in __module)\n"
		+ "	eval(\"var \" + n + \" = __module[n];\");\n";
};


});require.register("classdef.js", function(module, exports, require, global){
var Class = require("./Class");
var Type = require("./type");
eval(Class.$import("./util"));

"use strict";

var AnalysisContext = exports.AnalysisContext = Class.extend({

	initialize: function (errors, classDefs, funcDef) {
		this.errors = errors;
		this.classDefs = classDefs;
		this.funcDef = funcDef;
		this.blockStack = null;
	},

});

var ClassDefinition = exports.ClassDefinition = Class.extend({

	$IS_CONST: 1,
	$IS_ABSTRACT: 2,
	$IS_FINAL: 4,
	$IS_STATIC: 8,
	$IS_NATIVE: 16,
	$IS_OVERRIDE: 32,

	$getClass: function (classDefs, name) {
		for (var i = 0; i < classDefs.length; ++i)
			if (name == classDefs[i].className().getValue())
				return classDefs[i];
		return null;
	},

	initialize: function (className, flags, extendName, implementNames, members, objectTypesUsed) {
		this._className = className;
		this._flags = flags;
		this._extendName = extendName;
		this._extendClassDef = null;
		this._implementNames = implementNames;
		this._implementClassDefs = [];
		this._members = members;
		this._objectTypesUsed = objectTypesUsed;
	},

	serialize: function () {
		// FIXME implement in a way that is compatible with JSX
		return {
			"name"       : this._className.serialize(),
			"flags"      : this._flags,
			"extends"    : Util.serializeNullable(this._extendClassDef),
			"implements" : Util.serializeArray(this._implementClassDefs),
			"members"    : Util.serializeArray(this._members)
		};
	},

	$serialize: function (classDefs) {
		var s = [];
		for (var i = 0; i < classDefs.length; ++i)
			s[i] = classDefs[i].serialize();
		return JSON.stringify(s, null, 2);
	},

	className: function () {
		return this._className;
	},

	flags: function () {
		return this._flags;
	},

	extendName: function () {
		return this._extendName;
	},

	extendClassDef: function () {
		return tihs._extendClassDef;
	},

	implementNames: function () {
		return this._implementNames;
	},

	implementClassDefs: function () {
		return this._implementClassDefs;
	},

	members: function () {
		return this._members;
	},

	getMemberTypeByName: function (errors, classDefs, name, includeBaseClasses) {
		// returns an array to support function overloading
		var types = [];
		this._getMemberTypesByName(errors, classDefs, types, name, includeBaseClasses);
		switch (types.length) {
		case 0:
			return null;
		case 1:
			return types[0];
		default:
			return new Type.FunctionChoiceType(types);
		}
	},

	_getMemberTypesByName: function (errors, classDefs, types, name, includeBaseClasses) {
		if (! includeBaseClasses) {
			if (this._extendClassDef != null)
				this._extendClassDef._getMemberTypesByName(errors, classDefs, types, name, includeBaseClasses);
			for (var i = 0; i < this._implementClassDefs.length; ++i)
				this._implementClassDefs[i]._getMemberTypesByName(errors, classDefs, types, name, includeBaseClasses);
		}
		for (var i = 0; i < this._members.length; ++i) {
			var member = this._members[i];
			if (name == member.name() && (member.flags() & ClassDefinition.IS_OVERRIDE) == 0) {
				if (member instanceof MemberVariableDefinition) {
					var type = member.getType(errors, classDefs);
					// ignore member variables that failed in type deduction (already reported as a compile error)
					if (type != null)
						types.push(type);
				} else if (member instanceof MemberFunctionDefinition) {
					// member function
					types.push(member.getType());
				} else {
					throw new Error("logic flaw");
				}
			}
		}
	},

	resolveTypes: function (errors, classDefs) {
		// resolve extends
		if (this._extendName != null) {
			var baseClassName = Util.qualifiedNameToString(this._extendName);
			var baseClass = ClassDefinition.getClass(classDefs, baseClassName);
			if (baseClass == null)
				errors.push(new CompileError(this._extendName[0], "class '" + baseClassName + "' is not defined"));
			this._extendClassDef = baseClass;
		}
		// resolve implements
		for (var i = 0; i < this._implementNames.length; ++i) {
			var baseClassName = Util.qualifiedNameToString(this._implementNames[i]);
			var baseClass = ClassDefinition.getClass(classDefs, baseClassName);
			if (baseClass == null)
				errors.push(new CompileError(this._implementNames[i][0], "interface '" + baseClassName + "' is not defined"));
			this._implementsClassDefs.push(baseClass);
		}
		// resolve types used
		for (var i = 0; i < this._objectTypesUsed.length; ++i)
			this._objectTypesUsed[i].resolveType(errors, classDefs);
	},

	analyze: function (errors, classDefs) {
		for (var i = 0; i < this._members.length; ++i) {
			var member = this._members[i];
			// analysis of member variables are delayed (and those that where never analyzed will be removed by dead code elimination)
			if (member instanceof MemberFunctionDefinition)
				member.analyze(errors, classDefs, this);
		}
	},
});

var MemberDefinition = exports.MemberDefinition = Class.extend({

	initialize: function (identifierToken, flags) {
		this._identifierToken = identifierToken;
		this._flags = flags;
	},

	name: function () {
		return this._identifierToken.getValue();
	},

	flags: function () {
		return this._flags;
	}

});

var MemberVariableDefinition = exports.MemberVariableDefinition = MemberDefinition.extend({

	$NOT_ANALYZED: 0,
	$IS_ANALYZING: 1,
	$ANALYZE_SUCEEDED: 2,
	$ANALYZE_FAILED: 3,

	initialize: function (identifierToken, flags, type, initialValue) {
		MemberDefinition.call(this, identifierToken, flags);
		this._type = type; // may be null
		this._initialValue = initialValue; // may be null
		this._analyzeState = MemberVariableDefinition.NOT_ANALYZED;
	},

	serialize: function () {
		return {
			"name"         : this.name(),
			"flags"        : this.flags(),
			"type"         : this._type.serialize(),
			"initialValue" : Util.serializeNullable(this._initialValue)
		};
	},

	getType: function (errors, classDefs) {
		switch (this._analyzeState) {
		case MemberVariableDefinition.NOT_ANALYZED:
			try {
				this._analyzeState = MemberVariableDefinition.IS_ANALYZING;
				if (this._initialValue != null) {
					if (! this._initialValue.analyze(new AnalysisContext(errors, classDefs, null)))
						return;
					var ivType = this._initialValue.getType();
					if (this._type == null) {
						this._type = ivType;
					} else if (! this._type.equals(ivType)) {
						errors.push(new CompileError(this._initialValue,
							"conflicting types for variable '" + this.name + "', expected '" + this._type.toString(), "' but got '" + ivType.toString()));
					}
				}
				this._analyzeState = MemberVariableDefinition.ANALYZE_SUCEEDED;
			} finally {
				if (this._analyzeState != MemberVariableDefinition.ANALYZE_SUCEEDED)
					this._analyzeState = MemberVariableDefinition.ANALYZE_FAILED;
			}
			break;
		case MemberVariableDefinition.IS_ANALYZING:
			errors.push(new CompileError(this._identifierToken,
				"please declare type of variable '" + this._identifierToken.getValue() + "' (detected recursion while trying to reduce type)"));
			break;
		default:
			break;
		}
		return this._type;
	},

	getInitialValue: function () {
		return this._initialValue;
	}

});

var MemberFunctionDefinition = exports.MemberFunctionDefinition = MemberDefinition.extend({

	initialize: function (identifierToken, flags, returnType, args, locals, statements) {
		MemberDefinition.call(this, identifierToken, flags);
		this._returnType = returnType;
		this._args = args;
		this._locals = locals;
		this._statements = statements;
		this._classDef = null;
	},

	serialize: function () {
		return {
			"name"       : this.name(),
			"flags"      : this.flags(),
			"returnType" : this._returnType.serialize(),
			"args"       : Util.serializeArray(this._args),
			"locals"     : Util.serializeArray(this._locals),
			"statements" : Util.serializeArray(this._statements)
		};
	},

	analyze: function (errors, classDefs, classDef) {
		this._classDef = classDef;
		// return if is abtract (wo. function body) or is native
		if (this._statements == null)
			return;
		var context = new AnalysisContext(errors, classDefs, this);
		try {
			context.blockStack = []; // FIXME push something in
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack = null;
		}
	},

	getClassDef: function () {
		return this._classDef;
	},

	getReturnType: function () {
		return this._returnType;
	},

	getArguments: function () {
		return this._args;
	},

	getArgumentTypes: function () {
		var argTypes = [];
		for (var i = 0; i < this._args.length; ++i)
			argTypes[i] = this._args[i].getType();
		return argTypes;
	},

	// return list of local variables (omitting arguments)
	getLocals: function () {
		return this._locals;
	},

	getStatements: function () {
		return this._statements;
	},

	// return an argument or a local variable
	getLocal: function (name) {
		for (var i = 0; i < this._locals.length; ++i) {
			var local = this._locals[i];
			if (local.getName().getValue() == name)
				return local;
		}
		for (var i = 0; i < this._args.length; ++i) {
			var arg = this._args[i];
			if (arg.getName().getValue() == name)
				return arg;
		}
		return null;
	},

	getType: function () {
		return (this._flags & ClassDefinition.IS_STATIC) != 0
			? new Type.StaticFunctionType(this._returnType, this.getArgumentTypes(), false)
			: new Type.MemberFunctionType(new Type.ObjectType(this._classDef), this._returnType, this.getArgumentTypes(), false);
	}

});

var LocalVariable = exports.LocalVariable = Class.extend({

	initialize: function (name, type) {
		this._name = name;
		this._type = type;
	},

	serialize: function () {
		return [
			this._name,
			Util.serializeNullable(this._type)
		];
	},

	getName: function () {
		return this._name;
	},

	getType: function () {
		return this._type;
	},

	setType: function (type) {
		if (this._type != null)
			throw Error("type is already set");
		this._type = type;
	},

	toString: function () {
		return this._name + " : " + this._type;
	}
});

var ArgumentDeclaration = exports.ArgumentDeclaration = LocalVariable.extend({

	initialize: function (name, type) {
		LocalVariable.prototype.initialize.call(this, name, type);
	}

});

});require.register("compiler.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./parser"));
eval(Class.$import("./classdef"));
eval(Class.$import("./type"));
eval(Class.$import("./jsemitter"));
eval(Class.$import("./os"));
eval(Class.$import("./util"));

"use strict";

var Compiler = exports.Compiler = Class.extend({

	$MODE_COMPILE: 0,
	$MODE_PARSE: 1,

	initialize: function () {
		this._mode = Compiler.MODE_COMPILE;
		this._emitter = new JavaScriptEmitter();
		this._classDefs = [];
		this._output = "";
		// load the built-in classes
		this._sourceFiles = [
			"lib/built-in/Boolean.jsx",
			"lib/built-in/Number.jsx",
			"lib/built-in/String.jsx"
		];
		this._initializeFileCache();
		if (! this._precompile())
			throw new Error("logic flaw");
		Type._initializeBuiltin(this._classDefs);
		// reset source file list
		this._sourceFiles = [];
	},

	setMode: function (mode) {
		this._mode = mode;
		return this;
	},

	setEmitter: function (emitter) {
		this._emitter = emitter;
	},

	addSourceFile: function (file) {
		for (var i = 0; i < this._sourceFiles.length; ++i)
			if (this._sourceFiles[i] === file)
				return;
		this._sourceFiles.push(file);
	},

	compile: function () {
		if (! this._precompile())
			return false;
		switch (this._mode) {
		case Compiler.MODE_PARSE:
			this._output = ClassDefinition.serialize(this._classDefs);
			return true;
		}
		// TODO control flow analysis
		// TODO optimize
		this._generateCode();
		return true;
	},

	_precompile: function () {
		var errors = []; // new CompileError[]()
		// parse all files
		for (var i = 0; i < this._sourceFiles.length; ++i) {
			if (! this.parseFile(errors, this._sourceFiles[i])) {
				this._printErrors(errors);
				return false;
			}
		}
		switch (this._mode) {
		case Compiler.MODE_PARSE:
			return true;
		}
		// semantic analysis
		this._resolveTypes(errors);
		if (errors.length != 0) {
			this._printErrors(errors);
			return false;
		}
		this._analyze(errors);
		if (errors.length != 0) {
			this._printErrors(errors);
			return false;
		}
		return true;
	},

	getOutput: function() {
		return this._output;
	},

	_initializeFileCache: function() {
		// FIXME: omit ad-hoc require()
		if(typeof(process) !== 'undefined') { // node
			this._fileCache = {};
		}
		else { // browser
			this._fileCache =  Object.create(require('./_builtins'));
		}
	},

	getFileContent: function(filename) {
		if(this._fileCache[filename] == null) {
			this._fileCache[filename] = OS.readFile(filename);
		}
		return this._fileCache[filename];
	},

	parseFile: function (errors, filename) {
		// read file
		var content = this.getFileContent(filename);
		if (content == null) {
			errors.push("could not open the file");
			return false;
		}
		// parse
		var parser = new Parser(filename, content, errors);
		parser.parse();
		if (errors.length != 0)
			return false;
		// get the imported files from parser and set to _sourceFiles
		this._classDefs = this._classDefs.concat(parser.getClassDefs());
		return true;
	},

	_resolveTypes: function (errors) {
		for (var i = 0; i < this._classDefs.length; ++i)
			this._classDefs[i].resolveTypes(errors, this._classDefs);
	},

	_analyze: function (errors) {
		for (var i = 0; i < this._classDefs.length; ++i)
			this._classDefs[i].analyze(errors, this._classDefs);
	},

	_generateCode: function () {
		for (var i = 0; i < this._classDefs.length; ++i) {
			var classDef = this._classDefs[i];
			if ((classDef.flags() & ClassDefinition.IS_NATIVE) == 0)
				this._emitter.emitClassDefinition(classDef);
		}
		for (var i = 0; i < this._classDefs.length; ++i)
			this._emitter.emitStaticInitializationCode(this._classDefs[i]);
		this._output = this._emitter.getOutput();
	},

	_printErrors: function (errors) {
		for (var i = 0; i < errors.length; ++i) {
			// FIXME: errors is instanceof CompileError[],
			//        so this dynamic type check should be removed
			if (errors[i] instanceof CompileError) {
				OS.errprint(errors[i].format(this));
			}
			else {
				OS.errprint(errors[i].toString());
			}
		}
	}

});

// vim: set noexpandtab:

});require.register("dump.js", function(module, exports, require, global){
"use strict;"
/*
# NAME

dump - Dump data structures

# SYNOPSIS

var dump = require('path/to/dump');

dump.p(data);			   # outputs to console
foo.innerHTML = dump(data); # as string

*/

var dump;
try {
	dump = function() {
		var u = require('util');

		return function(data) {
			return u.inspect(data, false, 255);
		};
	}();
}
catch(e) {
	dump = function(data) {
		return JSON.stringify(data, null, 2);
	};
}

module.exports = dump;
dump.p = function(__va_args__) {
	Array.prototype.map.call(arguments, dump);
};


});require.register("emitter.js", function(module, exports, require, global){
var Class = require("./Class");

"use strict";

var Emitter = exports.Emitter = Class.extend({

	emitClassDefinition: null, // abstract function emitClassDefinition(:ClassDefinition):void

	emitStaticInitializationCode: null, // abstract function emitStaticInitializationCode(:ClassDefinition):void

	getOutput: null // abstract function getOutput() : String

});

});require.register("expression.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./classdef"));
eval(Class.$import("./type"));
eval(Class.$import("./util"));

"use strict";

var _Util = exports._Util = Class.extend({

	$analyzeArgs: function (context, args) {
		var argTypes = [];
		for (var i = 0; i < args.length; ++i) {
			if (! args[i].analyze(context))
				return null;
			argTypes[i] = args[i].getType();
		}
		if (argTypes == null)
			return null;
		return argTypes;
	}

});

var Expression = exports.Expression = Class.extend({

	analyze: null, // bool analyze(context)

	getType: null, // string getType()

	getHolderType: function () {
		return null;
	},

	isAssignable: function (type) {
		return false;
	}

});

var OperatorExpression = exports.OperatorExpression = Expression.extend({

	initialize: function (operatorToken) {
		this._operatorToken = operatorToken;
	},

	getOperatorToken: function() {
		return this._operatorToken;
	},

	assertIsConvertibleTo: function (context, expr, type) {
		var exprType = expr.getType();
		if (! exprType.isConvertibleTo(type)) {
			context.errors.push(new CompileError(this._operatorToken, "cannot apply operator '" + this._operatorToken.getValue() + "' to type '" + exprType.toString() + "'"));
			return false;
		}
		return true;
	}

});

// primary expressions

var IdentifierExpression = exports.IdentifierExpression = Expression.extend({

	initialize: function (identifierToken) {
		this._identifierToken = identifierToken;
		this._local = null;
		this._classDefType = null;
	},

	serialize: function () {
		if (this._local != null)
			return [
				"IdentifierExpression",
				this._identifierToken.serialize(),
				"local",
				Util.serializeNullable(this._local)
			];
		else
			return [
				"IdentifierExpression",
				this._identifierToken.serialize(),
				"classDef"
			];
	},

	analyze: function (context) {
		if ((this._local = context.funcDef.getLocal(this._identifierToken.getValue())) != null) {
			// ok
		} else {
			var classDef = ClassDefinition.getClass(context.classDefs, this._identifierToken.getValue());
			if (classDef == null) {
				context.errors.push(new CompileError(this._identifierToken, "local variable '" + this._identifierToken.getValue() + "' is not declared"));
				return false;
			}
			this._classDefType = new ClassDefType(classDef);
		}
		return true;
	},

	getType: function () {
		if (this._local != null)
			return this._local.getType();
		else
			return this._classDefType;
	},

	isAssignable: function (type) {
		if (this._local != null) {
			if (this._local.getType() == null) {
				this._local.setType(type.asAssignableType());
				return true;
			} else if (! type.isConvertibleTo(this._local.getType())) {
				return false;
			}
		} else {
			return this._classDefType.isAssignable();
		}
		return true;
	}

});

var NullExpression = exports.NullExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"NullExpression",
			this._token.serialize()
		];
	},

	analyze: function (context) {
		return true;
	},

	getType: function () {
		return Type.nullType;
	}

});


var BooleanLiteralExpression = exports.BooleanLiteralExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"BooleanLiteralExpression",
			this._token.serialize()
		];
	},

	analyze: function (context) {
		return true;
	},

	getType: function () {
		return Type.booleanType;
	}

});

var IntegerLiteralExpression = exports.IntegerLiteralExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"IntegerLiteralExpression",
			this._token.serialize()
		];
	},

	analyze: function (context) {
		return true;
	},

	getType: function () {
		return Type.integerType;
	}

});


var NumberLiteralExpression = exports.NumberLiteralExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"NumberLiteralExpression",
			this._token.serialize()
		];
	},

	analyze: function (context) {
		return true;
	},

	getType: function () {
		return Type.numberType;
	}

});

var StringLiteralExpression = exports.StringLiteralExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"StringLiteralExpression",
			this._token.serialize()
		];
	},

	analyze: function (context) {
		return true;
	},

	getType: function () {
		return Type.stringType;
	}

});

var ArrayLiteralExpression = exports.ArrayLiteralExpression = Expression.extend({

	initialize: function (token, exprs, type) {
		this._token = token;
		this._exprs = exprs;
		this._type = type; // optional at this moment
	},

	getToken: function () {
		return this._token;
	},

	getExprs: function () {
		return this._exprs;
	},

	getType: function () {
		return this._type;
	},

	serialize: function () {
		return [
			"ArrayLiteralExpression",
			this._token.serialize(),
			Util.serializeArray(this._exprs),
			Util.serializeNullable(this._type)
		];
	},

	analyze: function (context) {
		// analyze all elements
		var succeeded = true;
		for (var i = 0; i < this._exprs.length; ++i) {
			if (! this._exprs[i].analyze(context)) {
				succeeded = false;
			} else if (this._exprs[i].getType().equals(Type.voidType)) {
				 // FIXME the location of the error would be strange; we deseparately need expr.getToken()
				context.errors.push(new CompileError(this._token, "cannot assign void to an array"));
				suceeded = false;
			}
		}
		if (! succeeded)
			return false;
		// determine the type from the array members if the type was not specified
		if (this._type != null) {
			if (! (this._type instanceof ArrayType)) {
				context.errors.push(new CompileError(this._token, "specified type is not an array type"));
				return false;
			}
		} else {
			for (var i = 0; i < this._exprs.length; ++i) {
				var elementType = this._exprs[i].getType();
				if (! elementType.equals(Type.nullType)) {
					this._type = new ArrayType(elementType.equals(Type.integerType) ? Type.numberType : elementType);
					break;
				}
			}
			if (this._type == null) {
				context.errors.push(new CompileError(this._token, "could not deduce array type, please specify"));
				return false;
			}
		}
		// check type of the elements
		for (var i = 0; i < this._exprs.length; ++i) {
			var elementType = this._exprs[i].getType();
			if (! elementType.isConvertibleTo(this._type.getElementType())) {
				context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to an array of '" + this._type.toString() + "'"));
				succeeded = false;
			}
		}
		return succeeded;
	}

});

var HashLiteralElement = exports.HashLiteralElement = Class.extend({

	initialize: function (key, expr) {
		this._key = key;
		this._expr = expr;
	},

	getKey: function () {
		return this._key;
	},

	getExpr: function () {
		return this._expr;
	}

});

var HashLiteralExpression = exports.HashLiteralExpression = Expression.extend({

	initialize: function (token, elements, type) {
		this._token = token;
		this._elements = elements;
		this._type = type; // optional at this moment
	},

	getToken: function () {
		return this._token;
	},

	getElements: function () {
		return this._elements;
	},

	getType: function () {
		return this._type;
	},

	serialize: function () {
		return [
			"HashLiteralExpression",
			this._token.serialize(),
			Util.serializeArray(this._elements),
			Util.serializeNullable(this._type)
		];
	},

	analyze: function (context) {
		// analyze all elements
		var succeeded = true;
		for (var i = 0; i < this._elements.length; ++i) {
			if (! this._elements[i].getExpr().analyze(context)) {
				succeeded = false;
			} else if (this._elements[i].getExpr().getType().equals(Type.voidType)) {
				 // FIXME the location of the error would be strange; we deseparately need expr.getToken()
				context.errors.push(new CompileError(this._token, "cannot assign void to a hash"));
				suceeded = false;
			}
		}
		if (! succeeded)
			return false;
		// determine the type from the array members if the type was not specified
		if (this._type != null) {
			if (! (this._type instanceof HashType)) {
				context.errors.push(new CompileError(this._token, "specified type is not a hash type"));
				return false;
			}
		} else {
			for (var i = 0; i < this._elements.length; ++i) {
				var elementType = this._elements[i].getType();
				if (! elementType.equals(Type.nullType)) {
					this._type = new HashType(elementType.equals(Type.integerType) ? Type.numberType : elementType);
					break;
				}
			}
			if (this._type == null) {
				context.errors.push(new CompileError(this._token, "could not deduce hash type, please specify"));
				return false;
			}
		}
		// check type of the elements
		for (var i = 0; i < this._elements.length; ++i) {
			var elementType = this._elements[i].getExpr().getType();
			if (! elementType.isConvertibleTo(this._type.getElementType())) {
				context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to a hash of '" + this._type.toString() + "'"));
				succeeded = false;
			}
		}
		return succeeded;
	}

});

var ThisExpression = exports.ThisExpression = Expression.extend({

	initialize: function (token) {
		this._token = token;
		this._funcDef = null;
	},

	getToken: function () {
		return this._token;
	},

	serialize: function () {
		return [
			"ThisExpression",
			this._token.serialize(),
			Util.serializeNullable(this._funcDef)
		];
	},

	analyze: function (context) {
		this._funcDef = context.funcDef;
		return true;
	},

	getType: function () {
		if ((this._funcDef.flags() & ClassDefinition.IS_STATIC) != 0)
			return new ClassDefType(this._funcDef.getClassDef());
		else
			return new ObjectType(this._funcDef.getClassDef());
	}

});

// unary expressions

var UnaryExpression = exports.UnaryExpression = OperatorExpression.extend({

	initialize: function (operatorToken, expr) {
		OperatorExpression.prototype.initialize.call(this, operatorToken);
		this._expr = expr;
	},

	getExpr: function () {
		return this._expr;
	},

	serialize: function () {
		return [
			"UnaryExpression",
			this._operatorToken.serialize(),
			this._expr.serialize()
		];
	},

	analyze: function (context) {
		if (! this._expr.analyze(context))
			return false;
		if (this._expr.getType().equals(Type.voidType)) {
			context.errors.push(new CompileError(this._operatorToken, "cannot apply operator '" + this._operatorToken.getValue() + "' against void"));
			return false;
		}
		return true;
	}

});

var BitwiseNotExpression = exports.BitwiseNotExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	getType: function () {
		return Type.booleanType;
	}

});

var DeleteExpression = exports.DeleteExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	getType: function () {
		throw new Error("FIXME");
	}

});

var InstanceofExpression = exports.InstanceofExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr1, expectedType) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr1);
		this._expectedType = expectedType;
	},

	serialize: function () {
		return [
			"InstanceofExpression",
			this._expr.serialize(),
			expectedType.serialize()
		];
	},

	analyze: function (context) {
		if (! UnaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! (this._expr.getType() instanceof ObjectType)) {
			context.errors.push(new CompileError(this._operatorToken, "operator 'instanceof' is only applicable to an object"));
			return false;
		}
		return true;
	},

	getType: function () {
		return Type.booleanType;
	}

});

var LogicalNotExpression = exports.LogicalNotExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	analyze: function (context) {
		if (! UnaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr, Type.booleanType))
			return false;
		return true;
	},

	getType: function () {
		return Type.booleanType;
	}

});

var IncrementExpression = exports.IncrementExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	serialize: function () {
		return [
			this._getClassName(),
			this._operatorToken.serialize(),
			this._expr.serialize()
		];
	},

	analyze: function (context) {
		if (! UnaryExpression.prototype.analyze.call(this, context))
			return false;
		var exprType = this._expr.getType();
		if (exprType == null) {
			context.errors.push(new CompileError(this._operatorToken, "type unknown"));
			return false;
		} else if (exprType.equals(Type.integerType) || exprType.equals(Type.numberType)) {
			// ok
		} else {
			context.errors.push(new CompileError(this._operatorToken, "cannot apply operator '" + this._operatorToken.getValue() + "' to a non-number"));
			return false;
		}
		return true;
	},

	getType: function () {
		return this._expr.getType();
	}

});

var PostIncrementExpression = exports.PostIncrementExpression = IncrementExpression.extend({

	initialize: function (operatorToken, expr) {
		IncrementExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	_getClassName: function() {
		return "PostIncrementExpression";
	}

});

var PreIncrementExpression = exports.PreIncrementExpression = IncrementExpression.extend({

	initialize: function (operatorToken, expr) {
		IncrementExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	_getClassName: function() {
		return "PreIncrementExpression";
	}

});

var PropertyExpression = exports.PropertyExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr1, identifierToken) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr1);
		this._identifierToken = identifierToken;
		this._type = null;
	},

	getIdentifierToken: function () {
		return this._identifierToken;
	},

	serialize: function () {
		return [
			"PropertyExpression",
			this._expr.serialize(),
			this._identifierToken.serialize(),
			Util.serializeNullable(this._type)
		];
	},

	analyze: function (context) {
		if (! UnaryExpression.prototype.analyze.call(this, context))
			return false;
		var exprType = this._expr.getType();
		if (exprType.equals(Type.voidType)) {
			context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of void"));
			return false;
		}
		if (exprType.equals(Type.nullType)) {
			context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of null"));
			return false;
		}
		if (exprType instanceof HashType) {
			this._type = exprType.getValueType();
		} else {
			var classDef = exprType.getClassDef();
			if ((this._type = classDef.getMemberTypeByName(context.errors, context.classDefs, this._identifierToken.getValue(), ! (exprType instanceof ClassDefType))) == null) {
				context.errors.push(new CompileError(this._identifierToken, "'" + exprType.toString() + "' does not have a property named '" + this._identifierToken.getValue()) + "'");
				return false;
			}
		}
		return true;
	},

	getType: function () {
		return this._type;
	},

	getHolderType: function () {
		var type = this._expr.getType();
		if (type instanceof PrimitiveType)
			type = new ObjectType(type.getClassDef());
		return type;
	},

	isAssignable: function (type) {
		if (! this._type.isAssignable())
			return false;
		if (! type.isConvertibleTo(this._type))
			return false;
		return true;
	},

});

var TypeofExpression = exports.TypeofExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	analyze: function (context) {
		throw new Error("FIXME");
	},

});

var SignExpression = exports.SignExpression = UnaryExpression.extend({

	initialize: function (operatorToken, expr) {
		UnaryExpression.prototype.initialize.call(this, operatorToken, expr);
	},

	analyze: function (context) {
		if (! UnaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr, Type.numberType))
			return false;
	},

	getType: function () {
		var type = this._expr.getType();
		if (type.equals(Type.numberType))
			return type;
		else
			return Type.integerType;
	}

});

// binary expressions

var BinaryExpression = exports.BinaryExpression = OperatorExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		OperatorExpression.prototype.initialize.call(this, operatorToken);
		this._expr1 = expr1;
		this._expr2 = expr2;
	},

	getFirstExpr: function() {
		return this._expr1;
	},
	getSecondExpr: function() {
		return this._expr2;
	},


	serialize: function () {
		return [
			"BinaryExpression",
			this._operatorToken.serialize(),
			this._expr1.serialize(),
			this._expr2.serialize()/*,
			Util.serializeNullable(this.getType())*/
		];
	},

	analyze: function (context) {
		if (! this._expr1.analyze(context))
			return false;
		if (! this._expr2.analyze(context))
			return false;
		return true;
	}

});

var AdditiveExpression = exports.AdditiveExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
		this._type = null;
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		var expr1Type = this._expr1.getType();
		var expr2Type = this._expr2.getType();
		if (expr1Type.isConvertibleTo(Type.numberType) && expr2Type.isConvertibleTo(Type.numberType)) {
			// ok
			this._type = (expr1Type instanceof NumberType) || (expr2Type instanceof NumberType)
				? Type.numberType : Type.integerType;
		} else if (expr1Type instanceof StringType && expr2Type instanceof StringType) {
			// ok
			this._type = expr1Type;
		} else {
			context.errors.push(new CompileError(this._operatorToken, "cannot apply operator '+' to '" + expr1Type.toString() + "' and '" + expr2Type.toString() + "'"));
			return false;
		}
		return true;
	},

	getType: function () {
		return this._type;
	}

});

var ArrayExpression = exports.ArrayExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
		this._type = null;
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		if (this._expr1.getType() instanceof ArrayType) {
			if (! this._expr2.getType().isConvertibleTo(Type.integerType)) {
				context.errors.push(new CompileError(this._operatorToken, "array index should be a number"));
				return false;
			}
			this._type = this._expr1.getType().getElementType();
		} else if (this._expr1.getType() instanceof HashType) {
			if (! this._expr2.getType().equals(StringType)) {
				context.errors.push(new CompileError(this._operatorToken, "hash key should be a string"));
				return false;
			}
			this._type = this._expr1.getType().getElementType();
		} else {
			context.errors.push(new CompileError(this._operatorToken, "cannot apply operator '[]' (only applicable to an array or a hash)"));
			return false;
		}
		return true;
	},

	getType: function () {
		return this._type;
	}

});

var AssignmentExpression = exports.AssignmentExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		var rhsType = this._expr2.getType();
		if (rhsType == null)
			return false;
		if (rhsType.equals(Type.voidType)) {
			context.errors.push(new CompileError(this._operatorToken, "cannot assign void"));
			return false;
		}
		if (rhsType instanceof ClassDefType) {
			context.errors.push(new CompileError(this._operatorToken, "cannot assign a class"));
			return false;
		}
		if (rhsType.equals(Type.nullType) && this._expr1.getType() == null) {
			context.errors.push(new CompileError(this._operatorToken, "cannot assign null to an unknown type"));
			return false;
		}
		if (! this._expr1.isAssignable(rhsType)) {
			context.errors.push(new CompileError(this._operatorToken, "cannot assign '" + rhsType.toString() + "' to '" + this._expr1.getType().toString()));
			return false;
		}
		return true;
	},

	getType: function () {
		return this._expr1.getType();
	}

});

// + - * / % < <= > >= & | ^
var BinaryNumberExpression = exports.BinaryNumberExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr1, Type.numberType))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr2, Type.numberType))
			return false;
		return true;
	},

	getType: function () {
		switch (this._operatorToken.getValue()) {
		case "+":
		case "-":
		case "*":
		case "/":
		case "%":
			if (this._expr1.getType().equals(Type.numberType) || this._expr2.getType().equals(Type.numberType))
				return Type.numberType;
			else
				return Type.integerType;
			break;
		case "<":
		case "<=":
		case ">":
		case ">=":
			return Type.booleanType;
		case "&":
		case "|":
		case "^":
			return Type.integerType;
		default:
			throw new Error("unexpected operator:" + this._operatorToken.getValue());
		}
	}

});

var EqualityExpression = exports.EqualityExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		var expr1Type = this._expr1.getType();
		var expr2Type = this._expr2.getType();
		if (expr1Type.equals(expr2Type)) {
			// ok
		} else if (expr1Type.isConvertibleTo(expr2Type) || expr2Type.isConvertibleTo(expr1Type)) {
			// ok
		} else {
			context.errors.push(new CompileError(this._operatorToken, "either side of operator == should be convertible from the other"));
			return false;
		}
		return true;
	},

	getType: function () {
		return Type.booleanType;
	}

});

var InExpression = exports.InExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		throw new Error("FIXME");
	},

	getType: function () {
		return Type.booleanType;
	}

});

var LogicalExpression = exports.LogicalExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr1, Type.booleanType))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr2, Type.booleanType))
			return false;
		return true;
	},

	getType: function () {
		return Type.booleanType;
	}

});

var ShiftExpression = exports.ShiftExpression = BinaryExpression.extend({

	initialize: function (operatorToken, expr1, expr2) {
		BinaryExpression.prototype.initialize.call(this, operatorToken, expr1, expr2);
	},

	analyze: function (context) {
		if (! BinaryExpression.prototype.analyze.call(this, context))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr1, Type.integerType))
			return false;
		if (! this.assertIsConvertibleTo(context, this._expr2, Type.integerType))
			return false;
		return true;
	},

	getType: function () {
		return Type.integerType;
	}

});

// (the only) tertary expression

var ConditionalExpression = exports.ConditionalExpression = OperatorExpression.extend({

	initialize: function (operatorToken, condExpr, ifTrueExpr, ifFalseExpr) {
		OperatorExpression.prototype.initialize.call(this, operatorToken);
		this._condExpr = condExpr;
		this._ifTrueExpr = ifTrueExpr;
		this._ifFalseExpr = ifFalseExpr;
		this._type = null;
	},

	getCondExpr: function () {
		return this._condExpr;
	},

	getIfTrueExpr: function () {
		return this._ifTrueExpr;
	},

	getIfFalseExpr: function () {
		return this._ifFalseExpr;
	},

	serialize: function () {
		return [
			"ConditionalExpression",
			this._operatorToken.serialize(),
			this._condExpr.serialize(),
			Util.serializeNullable(this._ifTrueExpr),
			this._ifFalseExpr.serialize()
		];
	},

	analyze: function (context) {
		if (! this._condExpr.analyze(context))
			return false;
		var condExprType = this._condExpr.getType();
		if (! condExprType.isConvertibleTo(Type.booleanType)) {
			context.errors.push(new CompileError(this._operatorToken, "condition should be convertible to bool"));
			return false;
		}
		var typeIfTrue;
		if (this._ifTrueExpr != null) {
			if (! this._ifTrueExpr.analyze(context))
				return false;
			typeIfTrue = this._ifTrueExpr.getType();
		} else {
			typeIfTrue = condExprType;
		}
		if (! this._ifFalseExpr.analyze(context))
			return false;
		var typeIfFalse = this._ifFalseExpr.getType();
		if (typeIfTrue.equals(typeIfFalse)) {
			// ok
			this._type = typeIfTrue;
		} else if (Type.isIntegerOrNumber(typeIfTrue) && Type.isIntegerOrNumber(typeIfFalse)) {
			// specal case
			this._type = Type.numberType;
		} else {
			context.errors.push(new CompileError(this._operatorToken, "returned types should be the same for operator ?: but got '" + typeIfTrue.toString() + "' and '" + typeIfFalse.toString() + "'"));
			return false;
		}
		return true;
	},

	getType: function () {
		return this._type;
	}

});

// invocation expressions

var CallExpression = exports.CallExpression = OperatorExpression.extend({

	initialize: function (operatorToken, expr, args) {
		OperatorExpression.prototype.initialize.call(this, operatorToken);
		this._expr = expr;
		this._args = args;
		this._type = null;
	},

	getExpr: function () {
		return this._expr;
	},

	getArguments: function () {
		return this._args;
	},

	serialize: function () {
		return [
			"CallExpression",
			this._operatorToken.serialize(),
			this._expr.serialize(),
			Util.serializeArray(this._args),
			Util.serializeNullable(this._type)
		];
	},

	analyze: function (context) {
		if (! this._expr.analyze(context))
			return false;
		var argTypes = _Util.analyzeArgs(context, this._args);
		if (argTypes == null)
			return false;
		var exprType = this._expr.getType();
		if (! (exprType instanceof FunctionType)) {
			context.errors.push(new CompileError(this._operatorToken, "cannot call a non-function"));
			return false;
		}
		if ((this._type = exprType.deduceByArgumentTypes(context, this._operatorToken, argTypes, ! (this._expr.getHolderType() instanceof ObjectType))) == null)
			return false;
		return true;
	},

	getType: function () {
		return this._type.getReturnType();
	}

});

var NewExpression = exports.NewExpression = OperatorExpression.extend({

	initialize: function (operatorToken, name, args) {
		OperatorExpression.prototype.initialize.call(this, operatorToken);
		this._name = name;
		this._args = args;
		this._type = null;
	},

	getName: function () {
		return this._name;
	},

	getArguments: function () {
		return this._args;
	},

	serialize: function () {
		return [
			"NewExpression",
			this._operatorToken.serialize(),
			Util.serializeArray(this._name),
			Util.serializeArray(this._args)
		];
	},

	analyze: function (context) {
		if (this._name.length != 1)
			throw new Error("FIXME");
		var classDef = ClassDefinition.getClass(context.classDefs, this._name[0].getValue());
		if (classDef == null) {
			context.errors.push(new CompileError(this._name[0], "no class definition for '" + this._name[0].getValue() + "'"));
			return false;
		}
		var argTypes = _Util.analyzeArgs(context, this._args);
		if (argTypes == null)
			return false;
		var ctorType = classDef.getMemberTypeByName(context.errors, context.classDefs, "initialize", false);
		var isCallable = false;
		if (ctorType != null)
			isCallable = ctorType.deduceByArgumentTypes(context, this._operatorToken, argTypes, false) != null;
		else
			isCallable = argTypes.length == 0;
		if (! isCallable) {
			context.errors.push(new CompileError(this._operatorToken, "cannot create an object of type '" + this._name[0].getValue() + "', arguments mismatch"));
			return false;
		}
		this._type = new ObjectType(classDef);
		return true;
	},

	getType: function () {
		return this._type;
	}

});

// comma expression is not treated as a binary expression (why? it should be)

var CommaExpression = exports.CommaExpression = Expression.extend({

	initialize: function (expr1, expr2) {
		this._expr1 = expr1;
		this._expr2 = expr2;
	},

	getFirstExpr: function () {
		return this._expr1;
	},

	getSecondExpr: function () {
		return this._expr2;
	},

	serialize: function () {
		return [
			"CommaExpression",
			this._expr1.serialize(),
			this._expr2.serialize()
		];
	},

	analyze: function (context) {
		return this._expr1.analyze(context)
			&& this._expr2.analyze(context);
	},

	getType: function () {
		return this._expr2.getType();
	}

});
// vim: set noexpandtab:

});require.register("jsemitter.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./classdef"));
eval(Class.$import("./type"));
eval(Class.$import("./expression"));
eval(Class.$import("./statement"));
eval(Class.$import("./emitter"));

// statement emitter

var _StatementEmitter = exports._StatementEmitter = Class.extend({

	initialize: function (emitter) {
		this._emitter = emitter;
	}

});

var _ExpressionStatementEmitter = exports._ExpressionStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(";\n", null);
	}

});

var _ReturnStatementEmitter = exports._ReturnStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		var expr = this._statement.getExpr();
		if (expr != null) {
			this._emitter._emit("return ", null);
			this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
			this._emitter._emit(";\n", null);
		} else {
			this._emitter._emit("return;\n", this._statement.getToken());
		}
	}

});

var _BreakStatementEmitter = exports._BreakStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		if (this._statement.getLabel() != null)
			throw new Error("FIXME _BreakStatementEmitter.emit (no support for labels)");
		this._emitter._emit("break;\n", this._statement.getToken());
	}

});

var _ContinueStatementEmitter = exports._ContinueStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		if (this._statement.getLabel() != null)
			throw new Error("FIXME _ContinueStatementEmitter.emit (no support for labels)");
		this._emitter._emit("continue;\n", this._statement.getToken());
	}

});

var _LabelStatementEmitter = exports._LabelStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		throw new Error("FIXME _LabelStatementEmitter.emit");
	}

});

var _DoWhileStatementEmitter = exports._DoWhileStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("do {\n", null);
		this._emitter._emitStatements(this._statement.getStatements());
		this._emitter._emit("} while (", null);
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(");\n", null);
	}

});

var _ForInStatementEmitter = exports._ForInStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		throw new Error("FIXME _ForInStatementEmitter.emit");
	}

});

var _ForStatementEmitter = exports._ForStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("for (", null);
		var initExpr = this._statement.getInitExpr();
		if (initExpr != null)
			this._emitter._getExpressionEmitterFor(initExpr).emit(0);
		this._emitter._emit("; ", null);
		var condExpr = this._statement.getCondExpr();
		if (condExpr != null)
			this._emitter._getExpressionEmitterFor(condExpr).emit(0);
		this._emitter._emit("; ", null);
		var postExpr = this._statement.getPostExpr();
		if (postExpr != null)
			this._emitter._getExpressionEmitterFor(postExpr).emit(0);
		this._emitter._emit(") {\n", null);
		this._emitter._emitStatements(this._statement.getStatements());
		this._emitter._emit("}\n", null);
	}

});

var _IfStatementEmitter = exports._IfStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("if (", null);
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(") {\n", null);
		this._emitter._emitStatements(this._statement.getOnTrueStatements());
		var ifFalseStatements = this._statement.getOnFalseStatements();
		if (ifFalseStatements != null) {
			this._emitter._emit("} else {\n", null);
			this._emitter._emitStatements(ifFalseStatements);
		}
		this._emitter._emit("}\n", null);
	}

});

var _SwitchStatementEmitter = exports._SwitchStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("switch (", null);
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(") {\n", null);
		this._emitter._emitStatements(this._statement.getStatements());
		this._emitter._emit("}\n", null);
	}

});

var _CaseStatementEmitter = exports._CaseStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._reduceIndent();
		this._emitter._emit("case ", null);
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(":\n", null);
		this._emitter._advanceIndent();
	}

});

var _DefaultStatementEmitter = exports._DefaultStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._reduceIndent();
		this._emitter._emit("default:\n", null);
		this._emitter._advanceIndent();
	}

});

var _WhileStatementEmitter = exports._WhileStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("while (", null);
		this._emitter._getExpressionEmitterFor(this._statement.getExpr()).emit(0);
		this._emitter._emit(") {\n", null);
		this._emitter._emitStatements(this._statement.getStatements());
		this._emitter._emit("}\n", null);
	}

});

var _TryStatementEmitter = exports._TryStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		throw new Error("FIXME _TryStatementEmitter.emit");
	}

});

var _AssertStatementEmitter = exports._AssertStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		throw new Error("FIXME _AssertStatementEmitter.emit");
	}

});

var _LogStatementEmitter = exports._LogStatementEmitter = _StatementEmitter.extend({

	initialize: function (emitter, statement) {
		_StatementEmitter.prototype.initialize.call(this, emitter);
		this._statement = statement;
	},

	emit: function () {
		this._emitter._emit("console.log(", null);
		var exprs = this._statement.getExprs();
		for (var i = 0; i < exprs.length; ++i) {
			if (i != 0)
				this._emitter._emit(", ", null);
			this._emitter._getExpressionEmitterFor(exprs[i]).emit(0);
		}
		this._emitter._emit(");\n", null);
	}

});

// expression emitter

var _ExpressionEmitter = exports._ExpressionEmitter = Class.extend({

	initialize: function (emitter) {
		this._emitter = emitter;
	}

});

var _IdentifierExpressionEmitter = exports._IdentifierExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var ident = this._expr._identifierToken.getValue();
		this._emitter._emit(ident, null);
	}

});

var _NullExpressionEmitter = exports._NullExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var token = this._expr.getToken();
		this._emitter._emit("null", token);
	}

});

var _BooleanLiteralExpressionEmitter = exports._BooleanLiteralExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var token = this._expr.getToken();
		this._emitter._emit(token.getValue(), token);
	}

});

var _IntegerLiteralExpressionEmitter = exports._IntegerLiteralExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var token = this._expr.getToken();
		this._emitter._emit("" + token.getValue(), token);
	}

});

var _NumberLiteralExpressionEmitter = exports._NumberLiteralExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var token = this._expr.getToken();
		this._emitter._emit("" + token.getValue(), token);
	}

});

var _StringLiteralExpressionEmitter = exports._StringLiteralExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var token = this._expr.getToken();
		// FIXME escape
		this._emitter._emit(token.getValue(), token);
	}

});

var _ArrayLiteralExpressionEmitter = exports._ArrayLiteralExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		this._emitter._emit("[", null);
		var exprs = this._expr.getExprs();
		for (var i = 0; i < exprs.length; ++i) {
			if (i != 0)
				this._emitter._emit(", ", null);
			this._emitter._getExpressionEmitterFor(exprs[i]).emit(0);
		}
		this._emitter._emit("]", null);
	}

});

var _ThisExpressionEmitter = exports._ThisExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		var emittingFunction = this._emitter._emittingFunction;
		if ((emittingFunction.flags() & ClassDefinition.IS_STATIC) != 0)
			this._emitter._emit(emittingFunction.getClassDef().className().getValue(), this._expr.getToken());
		else
			this._emitter._emit("this", this._expr.getToken());
	}

});

var _OperatorExpressionEmitter = exports._OperatorExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
	},

	emit: function (outerOpPrecedence) {
		var opPrecedence = this._getPrecedence();
		if (opPrecedence > outerOpPrecedence) {
			this._emitter._emit("(", null);
			this._emit();
			this._emitter._emit(")", null);
		} else {
			this._emit();
		}
	},

	_emit: null, // void emit()

	_getPrecedence: null // int _getPrecedence()

});


var _UnaryExpressionEmitter = exports._UnaryExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	_emit: function () {
		var opToken = this._expr.getOperatorToken();
		this._emitter._emit(opToken.getValue(), opToken);
		this._emitter._getExpressionEmitterFor(this._expr.getExpr()).emit(this._getPrecedence());
	},

	_getPrecedence: function () {
		return _UnaryExpressionEmitter._operatorPrecedence[this._expr.getOperatorToken().getValue()];
	},

	$_operatorPrecedence: {},

	$_setOperatorPrecedence: function (op, precedence) {
		_UnaryExpressionEmitter._operatorPrecedence[op] = precedence;
	}

});

var _PostfixExpressionEmitter = exports._PostfixExpressionEmitter = _UnaryExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_UnaryExpressionEmitter.prototype.initialize.call(this, emitter, expr);
	},

	_emit: function () {
		var opToken = this._expr.getOperatorToken();
		this._emitter._getExpressionEmitterFor(this._expr.getExpr()).emit(this._getPrecedence());
		this._emitter._emit(opToken.getValue(), opToken);
	},

	_getPrecedence: function () {
		return _PostfixExpressionEmitter._operatorPrecedence[this._expr.getOperatorToken().getValue()];
	},

	$_operatorPrecedence: {},

	$_setOperatorPrecedence: function (op, precedence) {
		_PostfixExpressionEmitter._operatorPrecedence[op] = precedence;
	}

});

var _InstanceofExpressionEmitter = exports._InstanceofExpressionEmitter = _UnaryExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_UnaryExpressionEmitter.prototype.initialize.call(this, emitter, expr);
	},

	_emit: function () {
		this._emitter._getExpressionEmitterFor(this._expr.getExpr()).emit(this._getPrecedence());
		this._emitter._emit(" instanceof ", opToken);
		var expectedType = this._expr.getExpectedType();
		this._emitter._emit(expectedType.toString(), expectedType);
	},

	_getPrecedence: function () {
		return _InstanceofExpressionEmitter._operatorPrecedence;
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_InstanceofExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _PropertyExpressionEmitter = exports._PropertyExpressionEmitter = _UnaryExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_UnaryExpressionEmitter.prototype.initialize.call(this, emitter, expr);
	},

	_emit: function () {
		this._emitter._getExpressionEmitterFor(this._expr.getExpr()).emit(this._getPrecedence());
		var identifierToken = this._expr.getIdentifierToken();
		this._emitter._emit(".", identifierToken);
		this._emitter._emit(identifierToken.getValue(), identifierToken);
	},

	_getPrecedence: function () {
		return _PropertyExpressionEmitter._operatorPrecedence;
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_PropertyExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _BinaryExpressionEmitter = exports._BinaryExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
		this._precedence = _BinaryExpressionEmitter._operatorPrecedence[this._expr.getOperatorToken().getValue()];
	},

	_emit: function () {
		var opToken = this._expr.getOperatorToken();
		this._emitter._getExpressionEmitterFor(this._expr.getFirstExpr()).emit(this._precedence);
		this._emitter._emit(" " + opToken.getValue() + " ", opToken);
		var secondExpr = this._expr.getSecondExpr();
		this._emitter._getExpressionEmitterFor(secondExpr).emit(this._precedence);
		var secondExprType = secondExpr.getType();
		if (secondExprType instanceof ResolvedFunctionType) {
			if (! secondExprType.isAssignable()
				&& (secondExpr.getHolderType().getClassDef().flags() & ClassDefinition.IS_NATIVE) == 0)
				this._emitter._emit(this._emitter._mangleFunctionArguments(secondExprType.getArgumentTypes()), null);
		} else if (secondExpr instanceof FunctionChoiceType) {
			throw new Error("logic flaw, should be resolved by expression.js");
		}
	},

	_getPrecedence: function () {
		return this._precedence;
	},

	$_operatorPrecedence: {},

	$_setOperatorPrecedence: function (op, precedence) {
		_BinaryExpressionEmitter._operatorPrecedence[op] = precedence;
	}

});

var _ArrayExpressionEmitter = exports._ArrayExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	_emit: function () {
		this._emitter._getExpressionEmitterFor(this._expr.getFirstExpr()).emit(_ArrayExpressionEmitter._operatorPrecedence);
		this._emitter._emit("[", this._expr.getOperatorToken());
		this._emitter._getExpressionEmitterFor(this._expr.getSecondExpr()).emit(_ArrayExpressionEmitter._operatorPrecedence);
		this._emitter._emit("]", null);
	},

	_getPrecedence: function () {
		return _ArrayExpressionEmitter._operatorPrecedence;
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_ArrayExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _ConditionalExpressionEmitter = exports._ConditionalExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	_emit: function () {
		var precedence = this._getPrecedence();
		var ifTrueExpr = this._expr.getIfTrueExpr();
		if (ifTrueExpr != null) {
			this._emitter._getExpressionEmitterFor(this._expr.getCondExpr()).emit(precedence);
			this._emitter._emit(" ? ", null);
			this._emitter._getExpressionEmitterFor(ifTrueExpr).emit(precedence);
			this._emitter._emit(" : ", null);
			this._emitter._getExpressionEmitterFor(this._expr.getIfFalseExpr()).emit(precedence);
		} else {
			this._emitter._getExpressionEmitterFor(this._expr.getCondExpr()).emit(precedence);
			this._emitter._emit(" || ", null);
			this._emitter._getExpressionEmitterFor(this._expr.getIfFalseExpr()).emit(precedence);
		}
	},

	_getPrecedence: function () {
		return this._expr.getIfTrueExpr() != null ? _ConditionalExpressionEmitter._operatorPrecedence : _BinaryExpressionEmitter._operatorPrecedence["||"];
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_ConditionalExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _CallExpressionEmitter = exports._CallExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	_emit: function () {
		this._emitter._getExpressionEmitterFor(this._expr.getExpr()).emit(_CallExpressionEmitter._operatorPrecedence);
		// append the mangled suffix if the base expression is a property expression specifying a function (that is not assigned to other property)
		var baseExpr = this._expr.getExpr();
		if (baseExpr instanceof PropertyExpression && ! baseExpr.getType().isAssignable()
			&& (baseExpr.getHolderType().getClassDef().flags() & ClassDefinition.IS_NATIVE) == 0) {
			this._emitter._emit(this._emitter._mangleFunctionArguments(baseExpr.getType().getArgumentTypes()), null);
		}
		this._emitter._emit("(", null);
		var args = this._expr.getArguments();
		for (var i = 0; i < args.length; ++i) {
			if (i != 0)
				this._emitter.emit(", ", null);
			this._emitter._getExpressionEmitterFor(args[i]).emit(0);
		}
		this._emitter._emit(")");
	},

	_getPrecedence: function () {
		return _CallExpressionEmitter._operatorPrecedence;
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_CallExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _NewExpressionEmitter = exports._NewExpressionEmitter = _OperatorExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_OperatorExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		this._emitter._emit("new ", null);
		var name = this._expr.getName();
		for (var i = 0; i < name.length; ++i) {
			if (i != 0)
				this._emitter._emit(".", null);
			this._emitter._emit(name[i].getValue(), name[i]);
		}
		this._emitter._emit("(", null);
		var args = this._expr.getArguments();
		for (var i = 0; i < args.length; ++i) {
			if (i != 0)
				this._emitter.emit(", ", null);
			this._emitter._getExpressionEmitterFor(args[i]).emit(0);
		}
		this._emitter._emit(")");
	},

	_getPrecedence: function () {
		return _NewExpressionEmitter._operatorPrecedence;
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_NewExpressionEmitter._operatorPrecedence = precedence;
	}

});

var _CommaExpressionEmitter = exports._CommaExpressionEmitter = _ExpressionEmitter.extend({

	initialize: function (emitter, expr) {
		_ExpressionEmitter.prototype.initialize.call(this, emitter);
		this._expr = expr;
	},

	emit: function (outerOpPrecedence) {
		// comma operations should be surrounded by brackets unless within a comma expression, since "," might get considered as an argument separator (of function calls, etc.)
		var useBrackets = outerOpPrecedence != _CommaExpressionEmitter._operatorPrecedence;
		if (useBrackets)
			this._emitter._emit("(", null);
		this._emitter._getExpressionEmitterFor(this._expr.getFirstExpr()).emit(_CommaExpressionEmitter._operatorPrecedence);
		this._emitter._emit(", ", null);
		this._emitter._getExpressionEmitterFor(this._expr.getSecondExpr()).emit(_CommaExpressionEmitter._operatorPrecedence);
		if (useBrackets)
			this._emitter._emit(")", null);
	},

	$_operatorPrecedence: 0,

	$_setOperatorPrecedence: function (op, precedence) {
		_CommaExpressionEmitter._operatorPrecedence = precedence;
	}

});

// the global emitter

var JavaScriptEmitter = exports.JavaScriptEmitter = Class.extend({

	initialize: function () {
		this._output = "";
		this._indent = 0;
		this._emittingClass = null;
		this._emittingFunction = null;
	},

	emitClassDefinition: function (classDef) {

		try {
			this._emittingClass = classDef;

			var className = classDef.className().getValue();

			// emit constructor
			var ctors = this._findFunctions(classDef, "initialize", false);
			switch (ctors.length) {
			case 0:
				this._emitConstructor(classDef, null);
				break;
			case 1:
				this._emitConstructor(classDef, ctors[0]);
				break;
			default:
				throw new Error("FIXME");
			}

			// emit functions
			var members = classDef.members();
			for (var i = 0; i < members.length; ++i) {
				var member = members[i];
				if (member instanceof MemberFunctionDefinition) {
					if (! (member.name() == "initialize" && (member.flags() & ClassDefinition.IS_STATIC) == 0) && member.getStatements() != null) {
						this._emit("\n", null);
						this._emitFunction(member);
					}
				}
			}

		} finally {
			this._emittingClass = null;
		}

	},

	emitStaticInitializationCode: function (classDef) {
		var members = classDef.members();
		// FIXME can we (should we?) automatically resolve dependencies? isn't it impossible?
		for (var i = 0; i < members.length; ++i) {
			var member = members[i];
			if ((member instanceof MemberVariableDefinition)
				&& (member.flags() & (ClassDefinition.IS_STATIC | ClassDefinition.IS_NATIVE)) == ClassDefinition.IS_STATIC)
				this._emitMemberVariable(classDef.className().getValue(), member);
		}
	},

	getOutput: function () {
		return this._output;
	},

	_emitConstructor: function (classDef, funcDef) {
		// emit prologue
		this._emit("function " + classDef.className().getValue() + "(", null);
		if (funcDef != null)
			this._emitFunctionArguments(funcDef);
		this._emit(") {\n", null);
		this._advanceIndent();
		// emit member variable initialization code
		var members = classDef.members();
		for (var i = 0; i < members.length; ++i) {
			var member = members[i];
			if ((member instanceof MemberVariableDefinition) && (member.flags() & ClassDefinition.IS_STATIC) == 0)
				this._emitMemberVariable("this", member);
		}
		// emit function body
		if (funcDef != null)
			this._emitFunctionBody(funcDef);
		// emit epilogue
		this._reduceIndent();
		this._emit("}\n", null);
	},

	_emitFunction: function (funcDef) {
		this._emit(funcDef.getClassDef().className().getValue(), null);
		if ((funcDef.flags() & ClassDefinition.IS_STATIC) == 0)
			this._emit(".prototype", null);
		this._emit("." + this._mangleFunctionName(funcDef) + " = function (", null);
		this._emitFunctionArguments(funcDef);
		this._emit(") {\n", null);
		this._advanceIndent();
		this._emitFunctionBody(funcDef);
		this._reduceIndent();
		this._emit("};\n", null);
	},

	_emitFunctionArguments: function (funcDef) {
		var args = funcDef.getArguments();
		for (var i = 0; i < args.length; ++i) {
			if (i != 0)
				this._emit(", ");
			this._emit(args[i].getName().getValue());
		}
	},

	_emitFunctionBody: function (funcDef) {
		try {
			this._emittingFunction = funcDef;

			// emit local variable declarations
			var locals = funcDef.getLocals();
			for (var i = 0; i < locals.length; ++i) {
				this._emit("var " + locals[i].getName().getValue() + " = ");
				this._emitDefaultValueOf(locals[i].getType());
				this._emit(";\n", null)
			}
			// emit code
			var statements = funcDef.getStatements();
			for (var i = 0; i < statements.length; ++i)
				this._getStatementEmitterFor(statements[i]).emit();

		} finally {
			this._emittingFunction = null;
		}
	},

	_emitMemberVariable: function (holder, variable) {
		this._emit(holder + "." + variable.name() + " = ", null);
		var initialValue = variable.getInitialValue();
		if (initialValue != null)
			this._getExpressionEmitterFor(initialValue).emit(0);
		else
			this._emitDefaultValueOf(variable.getType());
		this._emit(";\n", null);
	},

	_emitDefaultValueOf: function (type) {
		if (type.equals(Type.booleanType))
			this._emit("false", null);
		else if (type.equals(Type.integerType) || type.equals(Type.numberType))
			this._emit("0", null);
		else
			this._emit("null", null);
	},

	_emitStatements: function (statements) {
		this._advanceIndent();
		for (var i = 0; i < statements.length; ++i)
			this._getStatementEmitterFor(statements[i]).emit();
		this._reduceIndent();
	},

	_emit: function (str, token) {
		if (this._output.match(/\n$/))
			this._output += this._getIdent();
		this._output += str.replace(/\n(.)/g, function (a, m) { "\n" + this._getIdent() + m; });
	},

	_advanceIndent: function () {
		++this._indent;
	},

	_reduceIndent: function () {
		if (--this._indent < 0)
			throw new Error("indent mistach");
	},

	_getIdent: function () {
		var s = "";
		for (var i = 0; i < this._indent; ++i)
			s += "\t";
		return s;
	},

	_getStatementEmitterFor: function (statement) {
		if (statement instanceof ExpressionStatement)
			return new _ExpressionStatementEmitter(this, statement);
		else if (statement instanceof ReturnStatement)
			return new _ReturnStatementEmitter(this, statement);
		else if (statement instanceof BreakStatement)
			return new _BreakStatementEmitter(this, statement);
		else if (statement instanceof ContinueStatement)
			return new _ContinueStatementEmitter(this, statement);
		else if (statement instanceof LabelStatement)
			return new _LabelStatementEmitter(this, statement);
		else if (statement instanceof DoWhileStatement)
			return new _DoWhileStatementEmitter(this, statement);
		else if (statement instanceof ForInStatement)
			return new _ForInStatementEmitter(this, statement);
		else if (statement instanceof ForStatement)
			return new _ForStatementEmitter(this, statement);
		else if (statement instanceof IfStatement)
			return new _IfStatementEmitter(this, statement);
		else if (statement instanceof SwitchStatement)
			return new _SwitchStatementEmitter(this, statement);
		else if (statement instanceof CaseStatement)
			return new _CaseStatementEmitter(this, statement);
		else if (statement instanceof DefaultStatement)
			return new _DefaultStatementEmitter(this, statement);
		else if (statement instanceof WhileStatement)
			return new _WhileStatementEmitter(this, statement);
		else if (statement instanceof TryStatement)
			return new _TryStatementEmitter(this, statement);
		else if (statement instanceof AssertStatement)
			return new _AssertStatementEmitter(this, statement);
		else if (statement instanceof LogStatement)
			return new _LogStatementEmitter(this, statement);
		throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize()));
	},

	_getExpressionEmitterFor: function (expr) {
		if (expr instanceof IdentifierExpression)
			return new _IdentifierExpressionEmitter(this, expr);
		else if (expr instanceof NullExpression)
			return new _NullExpressionEmitter(this, expr);
		else if (expr instanceof BooleanLiteralExpression)
			return new _BooleanLiteralExpressionEmitter(this, expr);
		else if (expr instanceof IntegerLiteralExpression)
			return new _IntegerLiteralExpressionEmitter(this, expr);
		else if (expr instanceof NumberLiteralExpression)
			return new _NumberLiteralExpressionEmitter(this, expr);
		else if (expr instanceof StringLiteralExpression)
			return new _StringLiteralExpressionEmitter(this, expr);
		else if (expr instanceof ArrayLiteralExpression)
			return new _ArrayLiteralExpressionEmitter(this, expr);
		else if (expr instanceof ThisExpression)
			return new _ThisExpressionEmitter(this, expr);
		else if (expr instanceof BitwiseNotExpression)
			return new _UnaryExpressionEmitter(this, expr);
		else if (expr instanceof DeleteExpression)
			return new _UnaryExpressionEmitter(this, expr);
		else if (expr instanceof InstanceofExpression)
			return new _InstanceofExpressionEmitter(this);
		else if (expr instanceof LogicalNotExpression)
			return new _UnaryExpressionEmitter(this, expr);
		else if (expr instanceof PostIncrementExpression)
			return new _PostfixExpressionEmitter(this, expr);
		else if (expr instanceof PreIncrementExpression)
			return new _UnaryExpressionEmitter(this, expr);
		else if (expr instanceof PropertyExpression)
			return new _PropertyExpressionEmitter(this, expr);
		else if (expr instanceof SignExpression)
			return new _UnaryExpressionEmitter(this, expr);
		else if (expr instanceof AdditiveExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof ArrayExpression)
			return new _ArrayExpressionEmitter(this, expr);
		else if (expr instanceof AssignmentExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof BinaryNumberExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof EqualityExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof InExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof LogicalExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof ShiftExpression)
			return new _BinaryExpressionEmitter(this, expr);
		else if (expr instanceof ConditionalExpression)
			return new _ConditionalExpressionEmitter(this, expr);
		else if (expr instanceof CallExpression)
			return new _CallExpressionEmitter(this, expr);
		else if (expr instanceof NewExpression)
			return new _NewExpressionEmitter(this, expr);
		else if (expr instanceof CommaExpression)
			return new _CommaExpressionEmitter(this, expr);
		throw new Error("got unexpected type of expression: " + JSON.stringify(expr.serialize()));
	},

	_mangleFunctionName: function (funcDef) {
		return funcDef.name() + this._mangleFunctionArguments(funcDef.getArgumentTypes());
	},

	_mangleTypeName: function (type) {
		if (type.equals(Type.voidType))
			return "V";
		else if (type.equals(Type.booleanType))
			return "B";
		else if (type.equals(Type.integerType))
			return "I";
		else if (type.equals(Type.numberType))
			return "N";
		else if (type.equals(Type.stringType))
			return "S";
		else if (type instanceof ArrayType)
			return "A" + this._mangleTypeName(type.getElementType());
		else if (type instanceof ObjectType)
			return "L" + this._mangleTypeString(type.toString());
		else if (type instanceof StaticFunctionType)
			return "F" + this._mangleFunctionArguments(type.getArgumentTypes());
		else if (type instanceof MemberFunctionType)
			return "M" + this._mangleTypeName(type.getObjectType()) + this._mangleFunctionArguments(type.getArgumentTypes());
		else
			throw new Error("FIXME " + type.toString());
	},

	_mangleFunctionArguments: function (argTypes) {
		var s = "" + argTypes.length;
		for (var i = 0; i < argTypes.length; ++i)
			s += this._mangleTypeName(argTypes[i]);
		return s;
	},

	_mangleTypeString: function (s) {
		return s.length + s;
	},

	_findFunctions: function (classDef, name, isStatic) {
		var functions = [];
		var members = classDef.members();
		for (var i = 0; i < members.length; ++i) {
			var member = members[i];
			if ((member instanceof MemberFunctionDefinition) && member.name() == name
				&& (member.flags() & ClassDefinition.IS_STATIC) == (isStatic ? ClassDefinition.IS_STATIC : 0))
				functions.push(member);
		}
		return functions;
	},

	$initialize: function () {
		var precedence = [
			[
				[ "new",        _NewExpressionEmitter._setOperatorPrecedence ],
				[ "[",          _ArrayExpressionEmitter._setOperatorPrecedence ],
				[ ".",          _PropertyExpressionEmitter._setOperatorPrecedence ],
				[ "(",          _CallExpressionEmitter._setOperatorPrecedence ],
			], [
				[ "++",         _PostfixExpressionEmitter._setOperatorPrecedence ],
				[ "--",         _PostfixExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "delete",     _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "void",       _UnaryExpressionEmitter._setOperatorPrecedence ],
				// typeof is not used by JSX
				[ "++",         _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "--",         _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "+",          _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "-",          _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "~",          _UnaryExpressionEmitter._setOperatorPrecedence ],
				[ "!",          _UnaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "*",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "/",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "%",          _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "+",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "-",          _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "<<",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">>",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">>>",        _BinaryExpressionEmitter._setOperatorPrecedence ],
			], [
				[ "<",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "<=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "instanceof", _InstanceofExpressionEmitter._setOperatorPrecedence ],
				[ "in",         _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "==",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "!=",         _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "&",          _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "^",          _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "|",          _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "&&",         _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "||",         _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "=",          _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "*=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "/=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "%=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "+=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "-=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "<<=",        _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">>=",        _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ ">>>=",       _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "&=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "^=",         _BinaryExpressionEmitter._setOperatorPrecedence ],
				[ "|=",         _BinaryExpressionEmitter._setOperatorPrecedence ]
			], [
				[ "?",          _ConditionalExpressionEmitter._setOperatorPrecedence ]
			], [
				[ ",",          _CommaExpressionEmitter._setOperatorPrecedence ]
			]
		];
		for (var i = 0; i < precedence.length; ++i) {
			var opTypeList = precedence[i];
			for (var j = 0; j < opTypeList.length; ++j)
				opTypeList[j][1](opTypeList[j][0], -(precedence.length - i));
		}
	}

});
// vim: set noexpandtab:

});require.register("os.js", function(module, exports, require, global){
var Class = require("./Class");

"use strict";

var fs;

if(typeof(process) !== 'undefined') { // node
	fs = require("fs");
}
else {
	fs = {};
	fs.readFileSync = function(id) {
		var element = document.getElementById(id);
		if(element == null) {
			throw new Error("Element not found: " + id);
		}
		return element.value;
	};
}

var OS = exports.OS = Class.extend({

	$readFile: function (filename) {
		return fs.readFileSync(filename).toString();
	},

	$errprint: function (str) {
		console.error(str);
	}

});

});require.register("parser.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./type"));
eval(Class.$import("./classdef"));
eval(Class.$import("./statement"));
eval(Class.$import("./expression"));
eval(Class.$import("./util"));

"use strict";

var Token = exports.Token = Class.extend({

	initialize: function (value, filename, pos) {
		this._value = value;
		this.filename = filename;
		this.pos = pos;
	},

	getValue: function () {
		return this._value;
	},

	serialize: function () {
		return [
			this.filename,
			this.pos,
			this._value
		];
	}

});

var _Lexer = exports._TokenTable = Class.extend({

	$makeAlt: function (patterns) {
		return "(?: \n" + patterns.join("\n | \n") + "\n)\n";
	},

	$quoteMeta: function (pattern) {
		return pattern.replace(/([^0-9A-Za-z_])/g, '\\$1');
	},

	$asHash: function (array) {
		var hash = {};
		for (var i = 0; i < array.length; ++i)
			hash[array[i]] = 1;
		return hash;
	},

	/// compile a regular expression
	$rx: function (pat, flags) {
		return RegExp(pat.replace(/[ \t\r\n]/g, ""), flags);
	},

	// static variables
	$initialize: function () {
		var ident         = " [a-zA-Z_] [a-zA-Z0-9_]* ";
		var doubleQuoted  = ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " ';
		var singleQuoted  = " '  [^'\\\\]* (?: \\\\. [^'\\\\]* )* ' ";
		var stringLiteral = this.makeAlt([singleQuoted, doubleQuoted]);
		var regexpLiteral = doubleQuoted.replace(/"/g, "/") + "[mgi]?";

		// ECMA 262 compatible,
		// see also ECMA 262 5th (7.8.3) Numeric Literals
		var decimalIntegerLiteral = "(?: 0 | [1-9][0-9]* )";
		var exponentPart = "(?: [eE] [+-]? [0-9]+ )";
		var numberLiteral = this.makeAlt([
				"(?: " + decimalIntegerLiteral + " \\. " +
				        "[0-9]* " + exponentPart + "? )",
				"(?: \\. [0-9]+ " + exponentPart + "? )",
				"(?: " + decimalIntegerLiteral + exponentPart + " )"
			]);
		var integerLiteral = this.makeAlt([
				"(?: 0 [xX] [0-9a-fA-F]+ )", // hex
				decimalIntegerLiteral
			]) + "(?![\\.0-9eE])";

		var multiLineComment  = "(?: /\\* (?: [^*] | (?: \\*+ [^*\\/]) )* \\*+/)";
		var singleLineComment = "(?: // [^\\r\\n]* )";
		var comment           = this.makeAlt([multiLineComment, singleLineComment]);
		var whiteSpace        = "[\\x20\\t\\r\\n]+";

		// regular expressions
		this.rxIdent          = this.rx("^" + ident);
		this.rxStringLiteral  = this.rx("^" + stringLiteral);
		this.rxNumberLiteral  = this.rx("^" + numberLiteral);
		this.rxIntegerLiteral = this.rx("^" + integerLiteral);
		this.rxRegExpLiteral  = this.rx("^" + regexpLiteral);
		this.rxSpace          = this.rx("^" + this.makeAlt([comment, whiteSpace]));

		// blacklists of identifiers
		this.keywords = this.asHash([
			// literals shared with ECMA 262
			"null",     "true",     "false",
			// keywords shared with ECMA 262
			"break",    "do",       "instanceof", "typeof",
			"case",     "else",     "new",        "var",
			"catch",    "finally",  "return",     "void",
			"continue", "for",      "switch",     "while",
			"function", "this",
			"default",  "if",       "throw",
			"delete",   "in",       "try",
			// keywords of JSX
			"class",	 "extends", "super",
			"import",    "implements",
			"interface", "static",
			"assert",    "log",
			"__FILE__",  "__LINE__"
		]);
		this.reserved = this.asHash([
			// literals of ECMA 262 but not used by JSX
			"debugger", "with",
			// future reserved words of ECMA 262
			"const", "export",
			// future reserved words within strict mode of ECMA 262
			"let",   "private",   "public", "yield",
			"protected",

			// JSX specific reserved words
			"extern", "native",
			"trait", "using",
			"as", "is",
			"operator", "package"
		]);
	}

});

var Parser = exports.Parser = Class.extend({

	initialize: function (filename, input, errors) {
		// lexer properties
		this._filename = filename;
		this._input = input;
		this._pos = 0;
		this._tokenLength = 0;
		// output
		this._errors = errors;
		this._classDefs = [];
		// use for function parsing
		this._locals = [];
		this._statements = [];
		this._objectTypesUsed = [];
	},

	parse: function () {

		/* FIXME decide the syntax and implement
		while (this._importStatementOpt())
			;
		if (this._hasErrors())
			return false;
		*/

		var classDef = this._classDefinition();
		if (classDef == null || this._errors.length != 0)
			return false;
		this._classDefs.push(classDef);

		if (! this._isEOF()) {
			this._newError("expected EOF");
			return false;
		}
		return true;
	},

	getClassDefs: function () {
		return this._classDefs;
	},

	_registerLocal: function (identifierToken, type) {
		for (var i = 0; i < this._locals.length; i++) {
			if (this._locals[i].getName().getValue() == identifierToken.getValue()) {
				if (type != null && ! this._locals[i].getType().equals(type))
					this._newError("conflicting types for variable " + identifierToken.getValue());
				return;
			}
		}
		this._locals.push(new LocalVariable(identifierToken, type));
	},

	_preserveState: function () {
		// FIXME use class
		return {
			// lexer properties
			pos: this._pos,
			tokenLength: this._tokenLength,
			// errors
			numErrors: this._errors.length
		};
	},

	_restoreState: function (state) {
		this._pos = state.pos;
		this._tokenLength = state.tokenLength;
		this._errors.length = state.numErrors;
	},

	_newError: function (message) {
		this._errors.push(new CompileError(this._filename, this._pos, message));
	},

	_advanceToken: function () {
		this._pos += this._tokenLength;
		this._tokenLength = 0;
		var matched;
		while ((matched = this._input.substring(this._pos).match(_Lexer.rxSpace)) != null)
			this._pos += matched[0].length;
	},

	_isEOF: function () {
		this._advanceToken();
		return this._input.length == this._pos;
	},

	_expectIsNotEOF: function () {
		if (this._isEOF()) {
			this._newError("unexpected EOF");
			return false;
		}
		return true;
	},

	_expectOpt: function (expected) {
		if (! (expected instanceof Array))
			expected = [ expected ];

		this._advanceToken();
		for (var i = 0; i < expected.length; ++i) {
			if (this._input.substring(this._pos, this._pos + expected[i].length) == expected[i]) {
				if (expected[i].match(_Lexer.rxIdent) != null
					&& this._input.substring(this._pos).match(_Lexer.rxIdent)[0].length != expected[i].length) {
					// part of a longer token
				} else {
					// found
					this._tokenLength = expected[i].length;
					return new Token(expected[i], this._filename, this._pos);
				}
			}
		}
		return null;
	},

	_expect: function (expected) {
		if (! (expected instanceof Array))
			expected = [ expected ];

		var token = this._expectOpt(expected);
		if (token == null) {
			this._newError("expected keyword: " + expected.join(" "));
			return null;
		}
		return token;
	},

	_expectIdentifierOpt: function () {
		this._advanceToken();
		var matched = this._input.substring(this._pos).match(_Lexer.rxIdent);
		if (matched == null)
			return null;
		if (_Lexer.keywords.hasOwnProperty(matched[0])) {
			this._newError("expected an identifier but found a keyword");
			return null;
		}
		if (_Lexer.reserved.hasOwnProperty(matched[0])) {
			this._newError("expected an identifier but found a reserved word");
			return null;
		}
		this._tokenLength = matched[0].length;
		return new Token(matched[0], this._filename, this._pos);
	},

	_expectIdentifier: function () {
		var token = this._expectIdentifierOpt();
		if (token != null)
			return token;
		this._newError("expected an identifier");
		return null;
	},

	_expectStringLiteralOpt: function () {
		this._advanceToken();
		var matched = this._input.substring(this._pos).match(_Lexer.rxStringLiteral);
		if (matched == null)
			return null;
		this._tokenLength = matched[0].length;
		return new Token(matched[0], this._filename, this._pos);
	},

	_expectNumberLiteralOpt: function () {
		this._advanceToken();
		var matched = this._input.substring(this._pos).match(_Lexer.rxIntegerLiteral);
		if (matched == null)
			matched = this._input.substring(this._pos).match(_Lexer.rxNumberLiteral);
		if (matched == null)
			return null;
		this._tokenLength = matched[0].length;
		return new Token(matched[0], this._filename, this._pos);
	},

	_expectRegExpLiteralOpt: function () {
		this._advanceToken();
		var matched = this._input.substring(this._pos).match(_Lexer.rxRegExpLiteral);
		if (matched == null)
			return null;
		this._tokenLength = matched[0].length;
		return new Token(matched[0], this._filename, this._pos);
	},

	_skipLine: function () {
		var matched = this._input.substring(this._pos).match(/^.*(?:\r\n?|\n|$)/);
		this._pos += matched[0].length;
		this._tokenLength = 0;
	},

	_qualifiedName: function () {
		var name = [];
		while (1) {
			var identifierToken;
			if ((identifierToken = this._expectIdentifier()) == null)
				return null;
			name.push(identifierToken);
			if (this._expectOpt(".") == null)
				break;
		}
		return name;
	},

	_classDefinition: function () {
		this._objectTypesUsed = [];
		// attributes* class
		var flags = 0;
		while (true) {
			var token = this._expect([ "class", "final", "native" ]);
			if (token == null)
				return null;
			if (token.getValue() == "class")
				break;
			var newFlag = 0;
			switch (token.getValue()) {
			case "final":
				newFlag = ClassDefinition.IS_FINAL;
				break;
			case "native":
				newFlag = ClassDefinition.IS_NATIVE;
				break;
			default:
				throw new Error("logic flaw");
			}
			if ((flags & newFlag) != 0) {
				this._newError("same attribute cannot be specified more than once");
				return null;
			}
			flags |= newFlag;
		}
		var className = this._expectIdentifier();
		if (className == null)
			return null;
		// extends
		var extendName = null;
		if (this._expectOpt("extends") != null)
			if ((extendName = this._qualifiedName()) == null)
				return null;
		// implements
		var implementNames = [];
		if (this._expectOpt("implements") != null) {
			do {
				var name = this._qualifiedName();
				if (name == null)
					return null;
				implementNames.push(name);
			} while (this._expectOpt(",") != null);
		}
		// body
		if (this._expect("{") == null)
			return null;
		var members = [];
		
		while (this._expectOpt("}") == null) {
			if (! this._expectIsNotEOF())
				return null;
			var member = this._memberDefinition(flags);
			if (member != null) {
				members.push(member);
			} else {
				this._skipLine();
			}
		}
		// done
		return new ClassDefinition(className, flags, extendName, implementNames, members, this._objectTypesUsed);
	},

	_memberDefinition: function (classFlags) {
		var flags = classFlags & ClassDefinition.IS_NATIVE;
		while (true) {
			var token = this._expect([ "function", "var", "static", "abstract", "override", "final", "const" ]);
			if (token == null)
				return null;
			if (token.getValue() == "function" || token.getValue() == "var")
				break;
			var newFlag = 0;
			switch (token.getValue()) {
			case "static":
				newFlag = ClassDefinition.IS_STATIC;
				break;
			case "abstract":
				newFlag = ClassDefinition.IS_ABSTRACT;
				break;
			case "override":
				newFlag = ClassDefinition.IS_OVERRIDE;
				break;
			case "final":
				newFlag = ClassDefinition.IS_FINAL;
				break;
			case "const":
				newFlag = ClassDefinition.IS_CONST;
				break;
			default:
				throw new Error("logic flaw");
			}
			if ((flags & newFlag) != 0) {
				this._newError("same attribute cannot be specified more than once");
				return null;
			}
			flags |= newFlag;
		}
		if (token.getValue() == "function")
			return this._functionDefinition(flags);
		var name = this._expectIdentifier();
		if (name == null)
			return null;
		var type = null;
		if (this._expectOpt(":") != null)
			if ((type = this._typeDeclaration(false)) == null)
				return null;
		var initialValue = null;
		if (this._expectOpt("=") != null)
			if ((initialValue = this._assignExpr(false)) == null)
				return null;
		if (type == null && initialValue == null) {
			this._newError("variable declaration should either have type declaration or initial value");
			return null;
		}
		if (! this._expect(";"))
			return null;
		return new MemberVariableDefinition(name, flags, type, initialValue);
	},

	_functionDefinition: function (flags) {
		if ((flags & ClassDefinition.IS_CONST) != 0) {
			this._newError("cannot declare a const function");
			return null;
		}
		// name
		var name = this._expectIdentifier();
		if (name == null)
			return null;
		if (name.getValue() == "initialize") {
			if ((flags & (ClassDefinition.IS_ABSTRACT | ClassDefinition.IS_FINAL)) != 0) {
				this._newError("constructor cannot be declared as 'abstract' or 'final'");
				return null;
			}
		}
		if (this._expect("(") == null)
			return null;
		// arguments
		var args = [];
		if (this._expectOpt(")") != null) {
		} else {
			while (true) {
				var argName = this._expectIdentifier();
				if (argName == null)
					return null;
				if (this._expect(":", "type declarations are mandatory for function arguments") == null)
					return null;
				var argType = this._typeDeclaration(false);
				if (argType == null)
					return null;
				// FIXME KAZUHO support default arguments
				args.push(new ArgumentDeclaration(argName, argType));
				if (this._expectOpt(")") != null)
					break;
				if (this._expect(",") == null)
					return null;
			}
		}
		// return type
		var returnType;
		if (name.getValue() == "initialize") {
			// no return type
			returnType = Type.voidType;
		} else {
			if (this._expect(":", "return type declaration is mandatory") == null)
				return null;
			returnType = this._typeDeclaration(true);
			if (returnType == null)
				return null;
		}
		// take care of abstract function
		if ((flags & ClassDefinition.IS_NATIVE) != 0) {
			if (this._expect(";") == null)
				return null;
			return new MemberFunctionDefinition(name, flags, returnType, args, null);
		} else if ((flags & ClassDefinition.IS_ABSTRACT) != 0) {
			var token = this._expect([ ";", "{" ]);
			if (token == null)
				return null;
			if (token.getValue() == ";")
				return new MemberFunctionDefinition(name, flags, returnType, args, null);
		} else {
			if (this._expect("{") == null)
				return null;
		}
		// body
		this._locals = [];
		this._statements = [];
		this._block();
		// done
		return new MemberFunctionDefinition(name, flags, returnType, args, this._locals, this._statements);
	},

	_typeDeclaration: function (allowVoid) {
		// FIXME support arrays and parameterized types
		if (allowVoid) {
			var keywordToken = this._expectOpt("void");
			if (keywordToken != null)
				return Type.voidType;
		}
		var typeDecl = this._primaryTypeDeclaration();
		// []
		while (this._expectOpt("[") != null) {
			if (this._expect("]") == null)
				return false;
			typeDecl = new ArrayType(typeDecl);
		}
		return typeDecl;
	},
	
	_primaryTypeDeclaration: function (allowVoid) {
		var keywordToken;
		if ((keywordToken = this._expectOpt("function")) != null)
			return _functionTypeDeclaration(null);
		var identifierToken = this._expectIdentifier();
		if (identifierToken == null)
			return null;
		switch (identifierToken.getValue()) {
		case "boolean":
			return Type.booleanType;
		case "int":
			return Type.integerType;
		case "number":
			return Type.numberType;
		case "String":
			return Type.stringType;
		default:
			// is object (or member function)
			var className = identifierToken.getValue();
			while (this._expectOpt(".") != null) {
				if ((keywordToken = this._expectOpt("function")) != null)
					break;
				var t = this._expectIdentifier();
				if (t == null)
					return null;
				className += "." + t.getValue();
			}
			var objectType = new ObjectType(className, identifierToken);
			this._objectTypesUsed.push(objectType);
			if (keywordToken != null)
				return this._functionTypeDeclaration(objectType); // function type
			return objectType;
		}
	},

	_functionTypeDeclaration: function (objectType) {
		// parse args
		if(this._expect("(") == null)
			return null;
		var argTypes = [];
		if (this._expectOpt(")") == null) {
			// no args
		} else {
			while (true) {
				this._expectIdentifierOpt(); // may have identifiers
				if (this._expect(":") == null)
					return null;
				var argType = this._typeDeclaration(false);
				if (argType == null)
					return null;
				argTypes.push(argType);
				var keywordToken = this_expect([ ")", "," ]);
				if (keywordToken == null)
					return null;
				if (keywordToken.getValue() == ")")
					break;
			}
		}
		// parse return type
		if (this._expect(":") == null)
			return false;
		var returnType = this._typeDeclaration(true);
		if (returnType == null)
			return null;
		if (className != null)
			return new MemberFunctionType(objectType, returnType, argTypes, true);
		else
			return new StaticFunctionType(returnType, argTypes, true);
	},

	_block: function () {
		while (this._expectOpt("}") == null) {
			if (! this._expectIsNotEOF())
				return false;
			if (! this._statement())
				this._skipLine();
		}
		return true;
	},

	_statement: function () {
		var token;
		if (this._expectOpt("{") != null)
			return this._block();
		else if (this._expectOpt("var") != null)
			return this._variableStatement();
		else if (this._expectOpt(";") != null)
			return true;
		else if (this._expectOpt("if") != null)
			return this._ifStatement();
		else if (this._expectOpt("do") != null)
			return this._doWhileStatement();
		else if (this._expectOpt("while") != null)
			return this._whileStatement();
		else if (this._expectOpt("for") != null)
			return this._forStatement();
		else if ((token = this._expectOpt("continue")) != null)
			return this._continueStatement(token);
		else if ((token = this._expectOpt("break")) != null)
			return this._breakStatement(token);
		else if ((token = this._expectOpt("return")) != null)
			return this._returnStatement(token);
		else if ((token = this._expectOpt("switch")) != null)
			return this._switchStatement(token);
		else if (this._expectOpt("throw") != null)
			return this._throwStatement();
		else if (this._expectOpt("try") != null)
			return this._tryStatement();
		else if ((token = this._expectOpt("assert")) != null)
			return this._assertStatement(token);
		else if ((token = this._expectOpt("log")) != null)
			return this._logStatement(token);
		// labelled or expression statement
		var state = this._preserveState();
		var identifier = this._expectIdentifierOpt();
		if (identifier != null && this._expectOpt(":") != null) {
			// label is treated as a separate statement (FIXME should label be an attribute of a statement?)
			this._statements.push(new LabelStatement(identifier));
			return true;
		}
		this._restoreState(state);
		// expression statement
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(";") == null)
			return null;
		this._statements.push(new ExpressionStatement(expr));
		return true;
	},

	_variableStatement: function () {
		var exprs = this._variableDeclarations(false);
		if (exprs == null)
			return false;
		if (this._expect(";") == null)
			return false;
		var mergedExpr = this._mergeExprs(exprs);
		if (mergedExpr == null)
			return true;
		this._statements.push(new ExpressionStatement(mergedExpr));
		return true;
	},

	_ifStatement: function () {
		if (this._expect("(") == null)
			return false;
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(")") == null)
			return false;
		var onTrueStatements = this._subStatements();
		var onFalseStatements = [];
		if (this._expectOpt("else") != null) {
			onFalseStatements = this._subStatements();
		}
		this._statements.push(new IfStatement(expr, onTrueStatements, onFalseStatements));
		return true;
	},

	_doWhileStatement: function () {
		var statements = this._subStatements();
		if (this._expect("while") == null)
			return false;
		if (this._expect("(") == null)
			return false;
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(")") == null)
			return false;
		this._statements.push(new DoWhileStatement(expr, statements));
		return true;
	},

	_whileStatement: function () {
		if (this._expect("(") == null)
			return false;
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(")") == null)
			return false;
		var statements = this._subStatements();
		this._statements.push(new WhileStatement(expr, statements));
		return true;
	},

	_forStatement: function () {
		var state = this._preserveState();
		// first try to parse as for .. in, and fallback to the other
		switch (this._forInStatement()) {
		case -1: // try for (;;)
			break;
		case 0: // error
			return false;
		case 1:
			return true;
		}
		this._restoreState(state);
		if (! this._expect("(") == null)
			return false;
		// parse initialization expression
		var initExpr = null;
		if (this._expectOpt(";") != null) {
			// empty expression
		} else if (this._expectOpt("var") != null) {
			var exprs = this._variableDeclarations(true);
			if (exprs == null)
				return false;
			if (this._expect(";") == null)
				return false;
			if (exprs.length != 0)
				initExpr = this._mergeExprs(exprs);
		} else {
			if ((initExpr = this._expr(true)) == null)
				return false;
			if (this._expect(";") == null)
				return false;
		}
		// parse conditional expression
		var condExpr = null;
		if (this._expectOpt(";") != null) {
			// empty expression
		} else {
			if ((condExpr = this._expr(false)) == null)
				return false;
			if (this._expect(";") == null)
				return false;
		}
		// parse post expression
		var postExpr = null;
		if (this._expectOpt(")") != null) {
			// empty expression
		} else {
			if ((postExpr = this._expr(false)) == null)
				return false;
			if (this._expect(")") == null)
				return false;
		}
		// statements
		var statements = this._subStatements();
		this._statements.push(new ForStatement(initExpr, condExpr, postExpr, statements));
		return true;
	},

	_forInStatement: function () {
		if (! this._expect("(") == null)
			return 0; // failure
		var lhsExpr;
		if (this._expectOpt("var") != null) {
			if ((lhsExpr = this._variableDeclaration(true)) == null)
				return -1; // retry the other
		} else {
			if ((lhsExpr = this._lhsExpr()) == null)
				return -1; // retry the other
		}
		if (this._expect("in") == null)
			return -1; // retry the other
		var expr = this._expr(false);
		if (expr == null)
			return 0;
		if (this._expect(")") != null)
			return 0;
		var statements = this._subStatements();
		this._statements.push(new ForInStatement(identifier, expr, statements));
		return 1;
	},

	_continueStatement: function (token) {
		var label = this._expectIdentifierOpt();
		if (this._expect(";") == null)
			return false;
		this._statements.push(new ContinueStatement(token, label));
		return true;
	},

	_breakStatement: function (token) {
		var label = this._expectIdentifierOpt();
		if (this._expect(";") == null)
			return false;
		this._statements.push(new BreakStatement(token, label));
		return true;
	},

	_returnStatement: function (token) {
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(";") == null)
			return null;
		this._statements.push(new ReturnStatement(token, expr));
		return true;
	},

	_switchStatement: function (token) {
		if (this._expect("(") == null)
			return false;
		var expr = this._expr(false);
		if (expr == null)
			return false;
		if (this._expect(")") == null
			|| this._expect("{") == null)
			return null;
		var foundCaseLabel = false;
		var foundDefaultLabel = false;
		// caseblock
		var startStatementIndex = this._statements.length;
		while (this._expectOpt("}") == null) {
			if (! this._expectIsNotEOF())
				return false;
			var caseOrDefaultToken;
			if (! foundCaseLabel && ! foundDefaultLabel) {
				// first statement within the block should start with a label
				if ((caseOrDefaultToken = this._expect([ "case", "default" ])) == null)
					return false;
			} else {
				caseOrDefaultToken = this._expectOpt([ "case", "default" ]);
			}
			if (caseOrDefaultToken != null) {
				if (caseOrDefaultToken.getValue() == "case") {
					var labelExpr = this._expr();
					if (labelExpr == null)
						return false;
					// FIXME check if expression is a constant known at compile time
					if (! (labelExpr instanceof NullExpression
						|| labelExpr instanceof BooleanLiteralExpression
						|| labelExpr instanceof IntegerLiteralExpression
						|| labelExpr instanceof NumberLiteralExpression
						|| labelExpr instanceof StringLiteralExpression)) {
						this._newError("case label is not a constant");
						return false;
					}
					if (this._expect(":") == null)
						return false;
					this._statements.push(new CaseStatement(caseOrDefaultToken, labelExpr));
					foundCaseLabel = true;
				} else { // "default"
					if (this._expect(":") == null)
						return false;
					if (foundDefaultLabel) {
						this._newError("cannot have more than one default statement within one switch block");
						return false;
					}
					this._statements.push(new DefaultStatement(caseOrDefaultToken));
					foundDefaultLabel = true;
				}
			} else {
				if (! this._statement())
					this._skipLine();
			}
		}
		// done
		this._statements.push(new SwitchStatement(token, expr, this._statements.splice(startStatementIndex)));
		return true;
	},

	_throwStatement: function () {
		var expr = this._expr();
		if (expr == null)
			return false;
		this._statements.push(new ThrowStatement(expr));
		return true;
	},

	_tryStatement: function () {
		if (this._expect("{") == null)
			return false;
		var startIndex = this._statements.length;
		if (! this._block())
			return false;
		var tryStatements = this._statements.splice(startIndex);
		var catchIdentifier = null;
		var catchStatements = null;
		if (this._expectOpt("catch") != null) {
			if (this._expect("(") == null
				|| (catchIdentifier = this._expectIdentifier()) == null
				|| this._expect(")") == null
				|| this._expect("{") == null)
				return false;
			if (! this._block())
				return false;
			catchStatements = this._statements.splice(startIndex);
		}
		var finallyStatements = null;
		if (this._expectOpt("finally") != null) {
			if (this._expect("{") == null)
				return false;
			finallyStatements = this._statements.splice(startIndex);
		}
		this._statements.push(new TryStatement(tryStatements, catchIdentifier, catchStatements, finallyStatements));
		return true;
	},

	_assertStatement: function (token) {
		var expr = this._expr();
		if (expr == null)
			return false;
		if (this._expect(";") == null)
			return false;
		this._statements.push(new AssertStatement(token, expr));
	},

	_logStatement: function (token) {
		var expr = this._commaSeparatedExprs(false);
		if (expr == null) {
			return false;
		}
		if (this._expect(";") == null)
			return null;
		this._statements.push(new LogStatement(token, expr));
		return true;
	},

	_subStatements: function () {
		var statementIndex = this._statements.length;
		if (! this._statement())
			this._skipLine();
		return this._statements.splice(statementIndex);
	},

	_variableDeclarations: function (noIn) {
		var exprs = [];
		do {
			var expr = this._variableDeclaration(noIn);
			if (expr == null)
				return null;
			// do not push variable declarations wo. assignment
			if (! (expr instanceof IdentifierExpression))
				exprs.push(expr);
		} while (this._expectOpt(",") != null);
		return exprs;
	},

	_variableDeclaration: function (noIn) {
		var identifier = this._expectIdentifier();
		if (identifier == null)
			return null;
		var type = null;
		if (this._expectOpt(":"))
			if ((type = _typeDeclaration(false)) == null)
				return null;
		var initialValue = null;
		var assignToken;
		if ((assignToken = this._expectOpt("=")) != null)
			if ((initialValue = this._assignExpr(noIn)) == null)
				return null;
		this._registerLocal(identifier, type);
		var expr = new IdentifierExpression(identifier);
		if (initialValue != null)
			expr = new AssignmentExpression(assignToken, expr, initialValue);
		return expr;
	},

	_mergeExprs: function (exprs) {
		if (exprs.length == 0)
			return null;
		var expr = exprs.shift();
		while (exprs.length != 0)
			expr = new CommaExpression(expr, exprs.shift());
		return expr;
	},

	_expr: function (noIn) {
		var exprs = this._commaSeparatedExprs(noIn);
		if (exprs == null)
			return exprs;
		var expr = exprs.shift();
		while (exprs.length != 0)
			expr = new CommaExpression(expr, exprs.shift());
		return expr;
	},

	_commaSeparatedExprs: function (noIn) {
		var expr = [];
		do {
			var assignExpr = this._assignExpr(noIn);
			if (assignExpr == null)
				return null;
			expr.push(assignExpr);
		} while (this._expectOpt(",") != null);
		return expr;
	},

	_assignExpr: function (noIn) {
		var state = this._preserveState();
		// FIXME contrary to ECMA 262, we first try lhs op assignExpr, and then condExpr; does this have any problem?
		// lhs
		var lhsExpr = this._lhsExpr();
		if (lhsExpr != null) {
			var op = this._expect([ "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=" ]);
			if (op != null) {
				var assignExpr = this._assignExpr(noIn);
				if (assignExpr != null)
					return new AssignmentExpression(op, lhsExpr, assignExpr);
			}
		}
		// failed to parse as lhs op assignExpr, try condExpr
		this._restoreState(state);
		return this._condExpr(noIn);
	},

	_condExpr: function (noIn) {
		var lorExpr = this._lorExpr(noIn);
		if (lorExpr == null)
			return null;
		var operatorToken;
		if ((operatorToken = this._expectOpt("?")) == null)
			return lorExpr;
		var ifTrueExpr = null;
		var ifFalseExpr = null;
		if (this._expectOpt(":") == null) {
			ifTrueExpr = this._assignExpr(noIn);
			if (ifTrueExpr == null)
				return null;
			if (this._expect(":") == null)
				return null;
		}
		ifFalseExpr = this._assignExpr(noIn);
		if (ifFalseExpr == null)
			return null;
		return new ConditionalExpression(operatorToken, lorExpr, ifTrueExpr, ifFalseExpr);
	},

	_binaryOpExpr: function (ops, parseFunc, noIn, builderFunc) {
		var expr = parseFunc.call(this, noIn);
		if (expr == null)
			return null;
		while (true) {
			var op = this._expectOpt(ops);
			if (op == null)
				break;
			var rightExpr = parseFunc.call(this);
			if (rightExpr == null)
				return null;
			expr = builderFunc(op, expr, rightExpr);
		}
		return expr;
	},

	_lorExpr: function (noIn) {
		return this._binaryOpExpr([ "||" ], this._landExpr, noIn, function (op, e1, e2) {
			return new LogicalExpression(op, e1, e2);
		});
	},

	_landExpr: function (noIn) {
		return this._binaryOpExpr([ "&&" ], this._borExpr, noIn, function (op, e1, e2) {
			return new LogicalExpression(op, e1, e2);
		});
	},

	_borExpr: function (noIn) {
		return this._binaryOpExpr([ "|" ], this._bxorExpr, noIn, function (op, e1, e2) {
			return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_bxorExpr: function (noIn) {
		return this._binaryOpExpr([ "^" ], this._bandExpr, noIn, function (op, e1, e2) {
			return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_bandExpr: function (noIn) {
		return this._binaryOpExpr([ "&" ], this._eqExpr, noIn, function (op, e1, e2) {
			return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_eqExpr: function (noIn) {
		return this._binaryOpExpr([ "==", "!=" ], this._relExpr, noIn, function (op, e1, e2) {
			return new EqualityExpression(op, e1, e2);
		});
	},

	_relExpr: function (noIn) {
		var ops = [ "<=", ">=", "<", ">" ];
		if (! noIn)
			ops.push("in");
		return this._binaryOpExpr(ops, this._shiftExpr, noIn, function (op, e1, e2) {
			if (op.getValue() == "in")
				return new InExpression(op, e1, e2);
			else
				return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_shiftExpr: function () {
		var expr = this._binaryOpExpr([ ">>>", "<<", ">>" ], this._addExpr, false, function (op, e1, e2) {
			return new ShiftExpression(op, e1, e2);
		});
		return expr;
	},

	_addExpr: function () {
		return this._binaryOpExpr([ "+", "-" ], this._mulExpr, false, function (op, e1, e2) {
			if (op.getValue() == "+")
				return new AdditiveExpression(op, e1, e2);
			else
				return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_mulExpr: function () {
		return this._binaryOpExpr([ "*", "/", "%" ], this._unaryExpr, false, function (op, e1, e2) {
			return new BinaryNumberExpression(op, e1, e2);
		});
	},

	_unaryExpr: function () {
		// simply remove "void"
		this._expectOpt("void");
		// read other unary operators
		var op = this._expectOpt([ "delete", "++", "--", "+", "-", "~", "!" ]);
		if (op == null)
			return this._postfixExpr();
		var expr = this._unaryExpr();
		if (expr == null)
			return null;
		switch (op.getValue()) {
		case "delete":
			return new DeleteExpression(op, expr);
			break;
		case "++":
		case "--":
			return new PreIncrementExpression(op, expr);
		case "+":
		case "-":
			return new SignExpression(op, expr);
		case "~":
			return new BitwiseNotExpression(op, expr);
		case "!":
			return new LogicalNotExpression(op, expr);
		}
	},

	_postfixExpr: function () {
		var expr = this._lhsExpr();
		var op = this._expectOpt([ "++", "--", "instanceof" ]);
		if (op == null)
			return expr;
		if (op.getValue() == "instanceof") {
			var type = this._typeDeclaration(false);
			if (type == null)
				return null;
			return new InstanceofExpression(op, expr, type);
		}
		return new PostIncrementExpression(op, expr);
	},

	_lhsExpr: function () {
		var expr;
		var newToken;
		if ((newToken = this._expectOpt("new")) != null) {
			// FIXME support namespaces and inner classes
			var name = this._qualifiedName();
			if (this._expect("(") == null)
				return null;
			var args = this._argsExpr();
			if (args == null)
				return null;
			expr = new NewExpression(newToken, name, args);
		} else {
			expr = this._primaryExpr();
		}
		if (expr == null)
			return null;
		var op;
		while ((op = this._expectOpt([ "(", "[", "." ])) != null) {
			switch (op.getValue()) {
			case "(":
				if ((args = this._argsExpr()) == null)
					return null;
				expr = new CallExpression(op, expr, args);
				break;
			case "[":
				var index = this._expr(false);
				if (index == null)
					return null;
				if (this._expect("]") == null)
					return null;
				expr = new ArrayExpression(op, expr, index);
				break;
			case ".":
				var identifier = this._expectIdentifier();
				if (identifier == null)
					return null;
				expr = new PropertyExpression(op, expr, identifier);
				break;
			}
		}
		return expr;
	},

	_primaryExpr: function () {
		var token;
		if ((token = this._expectOpt([ "this", "null", "false", "true", "[", "{", "(" ])) != null) {
			switch (token.getValue()) {
			case "this":
				return new ThisExpression(token);
			case "null":
				return new NullExpression(token);
			case "false":
				return new BooleanLiteralExpression(token);
			case "true":
				return new BooleanLiteralExpression(token);
			case "[":
				return this._arrayLiteral(token);
			case "{":
				return this._hashLiteral(token);
			case "(":
				var expr = this._expr(false);
				if (this._expect(")") == null)
					return null;
				return expr;
			}
		} else if ((token = this._expectIdentifierOpt()) != null) {
			return new IdentifierExpression(token);
		} else if ((token = this._expectNumberLiteralOpt()) != null) {
			return new NumberLiteralExpression(token);
		} else if ((token = this._expectStringLiteralOpt()) != null) {
			return new StringLiteralExpression(token);
		} else if ((token = this._expectRegExpLiteralOpt()) != null) {
			throw new Error("FIXME: RegExpExpression");
		} else {
			this._newError("expected primary expression");
		}
	},

	_arrayLiteral: function (token) {
		var exprs = [];
		if (this._expectOpt("]") == null) {
			do {
				var expr = this._assignExpr();
				if (expr == null)
					return null;
				exprs.push(expr);
				var token = this._expect([ ",", "]" ]);
				if (token == null)
					return null;
			} while (token.getValue() == ",");
		}
		var type = null;
		if (this._expectOpt(":") != null)
			if ((type = this._typeDeclaration(false)) == null)
				return null;
		return new ArrayLiteralExpression(token, exprs, type);
	},

	_hashLiteral: function (token) {
		var elements = [];
		if (this._expectOpt("}") == null) {
			do {
				// obtain key
				var keyToken;
				if ((keyToken = this._expectIdentifierOpt()) != null
					|| (keyToken = this._expectNumberLiteralOpt()) != null
					|| (keyToken = this._expectStringLiteralOpt()) != null) {
					// ok
				} else {
					this._newError("expected identifier, number or string but got '" + token.toString() + "'");
				}
				// separator
				if (this._expect(":") == null)
					return null;
				// obtain value
				var expr = this._assignExpr();
				if (expr == null)
					return null;
				elements.push(new HashElement(key, expr));
				// separator
				if ((token = this._expect([ ",", "}" ])) == null)
					return null;
			} while (token.getValue() == ",");
		}
		var type = null;
		if (this._expectOpt(":") != null)
			if ((type = this._typeDeclaration(false)) == null)
				return null;
		return new HashLiteralExpression(token, elements, type);
	},

	_argsExpr: function () {
		var args = [];
		if (this._expectOpt(")") == null) {
			do {
				var arg = this._assignExpr(false);
				if (arg == null)
					return null;
				args.push(arg);
				var token = this._expect([ ")", "," ]);
				if (token == null)
					return null;
			} while (token.getValue() == ",");
		}
		return args;
	}

});

});require.register("statement.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./expression"));
eval(Class.$import("./type"));
eval(Class.$import("./util"));

"use strict";

var Statement = exports.Statement = Class.extend({

	analyze: null, // void analyze(context)
	serialize: null
});

// statements that take one expression

var UnaryExpressionStatement = exports.UnaryExpressionStatement = Statement.extend({

	initialize: function (expr) {
		this._expr = expr;
	},

	getExpr: function () {
		return this._expr;
	},

	analyze: function (context) {
		this._expr.analyze(context);
	}

});
		
var ExpressionStatement = exports.ExpressionStatement = UnaryExpressionStatement.extend({

	initialize: function (expr) {
		UnaryExpressionStatement.prototype.initialize.call(this, expr);
	},

	serialize: function () {
		return [
			"ExpressionStatement",
			this._expr.serialize()
		];
	}

});

var ReturnStatement = exports.ReturnStatement = UnaryExpressionStatement.extend({

	initialize: function (token, expr) {
		UnaryExpressionStatement.prototype.initialize.call(this, expr);
		this._token = token;
	},

	serialize: function () {
		return [
			"ReturnStatement",
			this._expr.serialize()
		];
	},

	analyze: function (context) {
		if (! this._expr.analyze(context))
			return;
		var exprType = this._expr.getType();
		var returnType = context.funcDef.getReturnType();
		if (! exprType.isConvertibleTo(returnType))
			context.errors.push(new CompileError(this._token, "cannot convert '" + exprType.toString() + "' to return type '" + returnType.toString() + "'"));
	}

});

// break and continue

var JumpStatement = exports.JumpStatement = Statement.extend({

	initialize: function (token, label) {
		this._token = token;
		this._label = label;
	},

	getToken: function () {
		return this._token;
	},

	getLabel: function () {
		return this._label;
	},

	serialize: function () {
		return [
			this._getName(),
			this._token.serialize(),
			Util.serializeNullable(this._label)
		];
	},

	_assertIsJumpable: function (context) {
		if (this._label != null)
			throw new Error("FIXME");
		return true;
	}

});

var BreakStatement = exports.BreakStatement = JumpStatement.extend({

	initialize: function (token, label) {
		JumpStatement.prototype.initialize.call(this, token, label);
	},

	_getName: function () {
		return "BreakStatement";
	},

	analyze: function (context) {
		// check if the statement may appear
		var allowed = false;
		for (var i = context.blockStack.length - 1; i >= 0; --i) {
			var statement = context.blockStack[i];
			if (statement instanceof ForInStatement
				|| statement instanceof ForStatement
				|| statement instanceof DoWhileStatement
				|| statement instanceof WhileStatement
				|| statement instanceof SwitchStatement) {
				allowed = true;
				break;
			}
		}
		if (! allowed) {
			context.errors.push(new CompileError(this._token, "cannot break (a break statement is only allowed within the following statements: for/do-while/while/switch)"));
			return;
		}
		// check that it is possible to jump to the labelled statement
		this._assertIsJumpable();
	}

});

var ContinueStatement = exports.ContinueStatement = JumpStatement.extend({

	initialize: function (token, label) {
		JumpStatement.prototype.initialize.call(this, token, label);
	},

	_getName: function () {
		return "ContinueStatement";
	},


	analyze: function (context) {
		// check if the statement may appear
		var allowed = false;
		for (var i = context.blockStack.length - 1; i >= 0; --i) {
			var statement = context.blockStack[i];
			if (statement instanceof ForInStatement
				|| statement instanceof ForStatement
				|| statement instanceof DoWhileStatement
				|| statement instanceof WhileStatement) {
				allowed = true;
				break;
			}
		}
		if (! allowed) {
			context.errors.push(new CompileError(this._token, "cannot continue (a continue statement is only allowed within the following statements: for/do-while/while)"));
			return;
		}
		// check that it is possible to jump to the labelled statement
		this._assertIsJumpable();
	}

});

// label

var LabelStatement = exports.LabelStatement = Statement.extend({

	initialize: function (identifier) {
		this._identifier = identifier;
	},

	getIdentifier: function () {
		return this._identifier;
	},

	serialize: function () {
		return [
			"LabelStatement",
			this._identifier.serialize()
		];
	},

	analyze: function (context) {
	}

});

// control flow statements

var DoWhileStatement = exports.DoWhileStatement = Statement.extend({

	initialize: function (expr, statements) {
		this._expr = expr;
		this._statements = statements;
	},

	getExpr: function () {
		return this._expr;
	},

	getStatements: function () {
		return this._statements;
	},

	serialize: function () {
		return [
			"DoWhileStatement",
			this._expr.serialize(),
			Util.serializeArray(this._statements)
		];
	},

	analyze: function (context) {
		this._expr.analyze(context);
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var ForInStatement = exports.ForInStatement = Statement.extend({

	initialize: function (identifier, expr, statements) {
		this._identifier = identifier;
		this._expr = expr;
		this._statements = statements;
	},

	serialize: function () {
		return [
			"ForInStatement",
			this._identifier.serialize(),
			this._expr.serialize(),
			Util.serializeArray(this._statements)
		];
	},

	analyze: function (context) {
		this._expr.analyze(context);
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var ForStatement = exports.ForStatement = Statement.extend({

	initialize: function (initExpr, condExpr, postExpr, statements) {
		this._initExpr = initExpr;
		this._condExpr = condExpr;
		this._postExpr = postExpr;
		this._statements = statements;
	},

	getInitExpr: function () {
		return this._initExpr;
	},

	getCondExpr: function () {
		return this._condExpr;
	},

	getPostExpr: function () {
		return this._postExpr;
	},

	getStatements: function () {
		return this._statements;
	},

	serialize: function () {
		return [
			"ForStatement",
			Util.serializeNullable(this._initExpr),
			Util.serializeNullable(this._condExpr),
			Util.serializeNullable(this._postExpr),
			Util.serializeArray(this._statements)
		];
	},

	analyze: function (context) {
		if (this._initExpr != null)
			this._initExpr.analyze(context);
		if (this._condExpr != null)
			this._condExpr.analyze(context);
		if (this._postExpr != null)
			this._postExpr.analyze(context);
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var IfStatement = exports.IfStatement = Statement.extend({

	initialize: function (expr, onTrueStatements, onFalseStatements) {
		this._expr = expr;
		this._onTrueStatements = onTrueStatements;
		this._onFalseStatements = onFalseStatements;
	},

	getExpr: function () {
		return this._expr;
	},

	getOnTrueStatements: function () {
		return this._onTrueStatements;
	},

	getOnFalseStatements: function () {
		return this._onFalseStatements;
	},

	serialize: function () {
		return [
			"IfStatement",
			this._expr.serialize(),
			Util.serializeArray(this._onTrueStatements),
			Util.serializeArray(this._onFalseStatements)
		];
	},

	analyze: function (context) {
		this._expr.analyze(context);
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._onTrueStatements.length; ++i)
				this._onTrueStatements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._onFalseStatements.length; ++i)
				this._onFalseStatements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var SwitchStatement = exports.SwitchStatement = Statement.extend({

	initialize: function (token, expr, statements) {
		this._token = token;
		this._expr = expr;
		this._statements = statements;
	},

	getExpr: function () {
		return this._expr;
	},

	getStatements: function () {
		return this._statements;
	},

	serialize: function () {
		return [
			"SwitchStatement",
			this._expr.serialize(),
			Util.serializeArray(this._statements)
		];
	},

	analyze: function (context) {
		if (! this._expr.analyze(context))
			return;
		var exprType = this._expr.getType();
		if (! (exprType.equals(Type.booleanType) || exprType.equals(Type.integerType) || exprType.equals(Type.numberType) || exprType.equals(Type.stringType))) {
			context.errors.push(new CompileError(this._token, "switch statement only accepts boolean, number, or string expressions"));
			return;
		}
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var CaseStatement = exports.CaseStatement = Statement.extend({

	initialize: function (token, expr) {
		this._token = token;
		this._expr = expr;
	},

	getExpr: function () {
		return this._expr;
	},

	serialize: function () {
		return [
			"CaseStatement",
			this._expr.serialize()
		];
	},

	analyze: function (context) {
		if (! this._expr.analyze(context))
			return false;
		var statement = context.blockStack[context.blockStack.length - 1];
		if (! (statement instanceof SwitchStatement))
			throw new Error("logic flaw");
		var expectedType = statement.getExpr().getType();
		if (this._expr.getType().equals(expectedType)) {
			// ok
		} else if (Type.isIntegerOrNumber(this._expr.getType()) && Type.isIntegerOrNumber(expectedType)) {
			// ok
		} else if (expectedType.equals(Type.stringType) && this._expr.getType().equals(Type.nullType)) {
			// ok
		} else {
			context.errors.push(new CompileError(this._token, "type mismatch; expected type was '" + expectedType.toString() + "' but got '" + this._expr.getType() + "'"));
		}
	}

});

var DefaultStatement = exports.DefaultStatement = Statement.extend({

	initialize: function (token) {
		this._token = token;
	},

	serialize: function () {
		return [
			"DefaultStatement"
		];
	},

	analyze: function (context) {
	}

});

var WhileStatement = exports.WhileStatement = Statement.extend({

	initialize: function (expr, statements) {
		this._expr = expr;
		this._statements = statements;
	},

	getExpr: function () {
		return this._expr;
	},

	getStatements: function () {
		return this._statements;
	},

	serialize: function () {
		return [
			"WhileStatement",
			this._expr.serialize(),
			Util.serializeArray(this._statements)
		];
	},

	analyze: function (context) {
		this._expr.analyze(context);
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._statements.length; ++i)
				this._statements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
	}

});

var TryStatement = exports.TryStatement = Statement.extend({

	initialize: function (tryStatements, catchIdentifier, catchStatements, finallyStatements) {
		this._tryStatements = tryStatements;
		this._catchIdentifier = catchIdentifier; // FIXME type?
		this._catchStatements = catchStatements;
		this._finallyStatements = finallyStatements;
	},

	serialize: function () {
		return [
			"TryStatement",
			Util.serializeArray(this._tryStatements),
			Util.serializeNullable(this._catchIdentifier),
			Util.serializeArray(this._catchStatements),
			Util.serializeArray(this._finallyStatements)
		];
	},

	analyze: function (context) {
		try {
			context.blockStack.push(this);
			for (var i = 0; i < this._tryStatements.length; ++i)
				this._tryStatements[i].analyze(context);
		} finally {
			context.blockStack.pop();
		}
		if (this._catchStatements != null) {
			try {
				context.blockStack.push(this);
				for (var i = 0; i < this._catchStatements.length; ++i)
					this._catchStatements[i].analyze(context);
			} finally {
				context.blockStack.pop();
			}
		}
		if (this._finallyStatements != null) {
			try {
				context.blockStack.push(this);
				for (var i = 0; i < this._finallyStatements.length; ++i)
					this._finallyStatements[i].analyze(context);
			} finally {
				context.blockStack.pop();
			}
		}
	}

});

// information statements

var InformationStatement = exports.InformationStatement = Statement.extend({

	initialize: function (token, exprs) {
		this._token = token;
		this._exprs = exprs;
	},

	getToken: function () {
		return this._token;
	},

	getExprs: function () {
		return this._exprs;
	},

	_analyzeExprs: function (context) {
		for (var i = 0; i < this._exprs.length; ++i)
			if (! this._exprs[i].analyze(context))
				return false;
		return true;
	}

});

var AssertStatement = exports.AssertStatement = InformationStatement.extend({

	initialize: function (token, exprs) {
		InformationStatement.prototype.initialize.call(this, token, exprs);
	},

	serialize: function () {
		return [
			"AssertStatement",
			Util.serializeArray(this._exprs)
		];
	},

	analyze: function (context) {
		if (! this._analyzeExprs(context))
			return;
		var exprType = this._exprs[this._exprs.length - 1].getType();
		if (exprType.equals(Type.voidType))
			context.errors.push(new CompileError(this._token, "cannot assert type void"));
		else if (exprType.equals(Type.nullType))
			context.errors.push(new CompileError(this._token, "assertion never succeeds"));
	}

});

var LogStatement = exports.LogStatement = InformationStatement.extend({

	initialize: function (token, exprs) {
		InformationStatement.prototype.initialize.call(this, token, exprs);
	},

	serialize: function () {
		return [
			"LogStatement",
			Util.serializeArray(this._exprs)
		];
	},

	analyze: function (context) {
		if (! this._analyzeExprs(context))
			return;
		for (var i = 0; i < this._exprs.length; ++i) {
			if (this._exprs[i].getType().equals(Type.voidType)) {
				context.errors.push(new CompileError(this._token, "cannot log a void expression"));
				break;
			}
		}
	}

});

});require.register("Test.js", function(module, exports, require, global){
"use strict";
/*
# NAME

Test - Nestable Testing libraries

# SYNOPSIS

	var Test = require('/path/to/Test');

	var test = new Test(__filename); // create a test case

	test.beforeEach(function() { ... });
	test.afterEach(function() { ... });

	test.describe('first test case', function(t) {
		var x = 42;

		t.expect(x).toBe(42);
		t.expect(x).notToBe(3.14);
		t.expect(x).toBeFalsy('message');

		return 'foo';
	}).next('second test case', function(t, value) {
		t.expect(vallue).toBe('foo');
	});

	test.done();
*/


var Class = require("./Class");
var dump  = require("./dump");

var Test = module.exports = Class.extend({
	initialize: function(filename, parent) {
		this._parent  = parent;
		this._name	= filename;
		this._count   = 0;
		this._pass	= 0;
		this._start   = Date.now();
		this._status  = 0; // exit code

		this.verbose = true;
		if(typeof(process) !== 'undefined' && !process.stdout.isTTY) {
			this.verbose = false;
		}

		this.note('Testing', this.toString());
	},

	toString: function() {
		return 'Test(' + dump(this._name) + ')';
	},

	describe: function(name, block) {
		this._doBlock(name, block);
		return this;
	},

	next: function(name, block) {
		if(this._nextArg == null) {
			this._ok(false, name);
		}
		else {
			this._doBlock(name, block, this._nextArg);
		}
		return this;
	},

	setNextArg: function(nextArg) {
		this._nextArg = nextArg;
	},

	_doBlock: function(name, block, nextArg) {
		var subtest = new Test.Subtest(name, this);
		this.note(name);
		try {
			if(nextArg != null) {
				block(subtest, nextArg);
			}
			else {
				block(subtest);
			}
		} catch(e) {
			this._status = 1;

			this.fail('subtest ' + name + "\n" + e.stack);

			subtest.done(null);
		}
	},

	expect: function(value, message) {
		return new Test.Matcher(this, ++this._count, value, message);
	},

	fail: function(message) {
		++this._count;
		this._ok(false, message);
	},

	_ok: function(result, message, diagnostics) {
		var args = [];

		if(result) {
			++this._pass;
			args.push('ok');
		}
		else {
			args.push('not ok');
		}

		args.push(this._count);

		args.push('-', message);
		this.log.apply(this, args);

		if(diagnostics != null) {
			this.diag(this._makeMessage( (new Error(diagnostics)).stack ));
		}
	},

	done: function() {
		this.log('1..' + this._count);

		if(this._count !== this._pass) {
			this.diag('Looks like you failed',
					  (this._count - this._pass),
					  'test of', this._count);
			this._status = 1;
		}
		this.note('elapsed', Date.now() - this._start, 'ms.');

		process.exit(this._status);
	},

	// format mes
	// sages
	_makeMessage: function(__va_args__) {
		var m = Array.prototype.join.call(arguments, ' ');
		var s = m.split(/\n/);
		var first = s.shift();

		if(s.length === 0) {
			return first;
		}
		else {
			return first + "\n" + s.join("\n").replace(/^/mg, '# ');
		}
	},

	explain: function(v) {
		return dump(v);
	},

	note: function(__va_args__) {
		if(!this.verbose) {
			return;
		}

		var m = Array.prototype.join.call(arguments, ' ');
		console.warn('# ' + this._makeMessage(m));
	},
	diag: function(__va_args__) {
		var m = Array.prototype.join.call(arguments, ' ');
		console.warn('# ' + this._makeMessage(m));
	},
	log: function(__va_args__) {
		var m = Array.prototype.join.call(arguments, ' ');
		console.log(m);
	}
});

Test.Subtest = Class.extend({
	initialize: function(name, parent) {
		this._name   = name;
		this._parent = parent;
	},
	toString: function() {
		return this._parent.toString() + '.' +
			'Subtest(' + dump(this._name) + ')';
	},

	done: function(nextArg) {
		this._parent.setNextArg(nextArg);
	},

	describe: function(_) {
		this._parent.describe.apply(this._parent, arguments);
	},
	next: function(_) {
		this._parent.next.apply(this._parent, arguments);
	},

	expect: function(_) {
		return this._parent.expect.apply(this._parent, arguments);
	},

	explain: function(_) {
		return this._parent.explain.apply(this._parent, arguments);
	},
	note: function(_) {
		this._parent.note.apply(this._parent, arguments);
	},
	diag: function(_) {
		this._parent.diag.apply(this._parent, arguments);
	},
	log: function(_) {
		this._parent.log.apply(this._parent, arguments);
	}
});

Test.Matcher = Class.extend({
	initialize: function(context, id, value, message) {
		this._context = context;
		this._id      = id;
		this._value   = value;
		this._message = message;
	},
	toString: function() {
		return 'Test.Matcher( #' + id + " "+ dump(this._value) +  ')';
	},

	// matchers
	toBe: function(expected) {
		if(this._value === expected) {
			this._context._ok(true, this._message);
		}
		else {
			this._context._ok(false, this._message,
				"Failed to test " + this._id + "\n" +
				"Expected: " + dump(expected) + "\n" +
				"Got:      " + dump(this._value) + "\n"
			);
		}
	},
	toBeInstanceOf: function(expectedClass) {
		if(this._value instanceof expectedClass) {
			this._context._ok(true, this._message);
		}
		else {
			this._context._ok(false, this._message,
				"Failed to test " + this._id + "\n" +
				"Expected class: " + expectedClass + "\n" +
				"Got instance:   " + this._value + "\n"
			);
		}
	},
	toBeTruthy: function() {
		if(this._value) {
			this._context._ok(true, this._message);
		}
		else {
			this._context._ok(false, this._message,
				"Failed to test " + this._id + " to be truthy\n" +
				"Got: " + dump(this._value) + "\n"
			);
		}
	},
	toBeFalsy: function() {
		if(!this._value) {
			this._context._ok(true, this._message);
		}
		else {
			this._context._ok(false, this._message,
				"Failed to test " + this._id + " to be falsy\n" +
				"Got: " + dump(this._value) + "\n"
			);
		}
	}
});

});require.register("type.js", function(module, exports, require, global){
var Class = require("./Class");
eval(Class.$import("./classdef"));
eval(Class.$import("./util"));

"use strict";

// FIXME add support for arrays and parameterized types
var Type = exports.Type = Class.extend({

	$_initialize: function () {
		this.voidType = new VoidType();
		this.nullType = new NullType();
		this.booleanType = new BooleanType();
		this.integerType = new IntegerType();
		this.numberType = new NumberType();
		this.stringType = new StringType();
	},

	$_initializeBuiltin: function (classDefs) {
		BooleanType._classDef = ClassDefinition.getClass(classDefs, "String");
		NumberType._classDef = ClassDefinition.getClass(classDefs, "Number");
		StringType._classDef = ClassDefinition.getClass(classDefs, "String");
	},

	serialize: function () {
		return this.toString();
	},

	isAssignable: null, // bool isAssignable()
	isConvertibleTo: null, // bool isConvertibleTo(type)
	getClassDef: null, // ClassDefinition getClassDef()

	equals: function (x) {
		return this == x || ((x instanceof Type) && this.toString() == x.toString());
	},

	asAssignableType: function () {
		return this;
	},

	$isIntegerOrNumber: function (type) {
		return type instanceof IntegerType || type instanceof NumberType;
	}

});

// void and null are special types

var VoidType = exports.VoidType = Type.extend({

	isAssignable: function () {
		return false;
	},

	isConvertibleTo: function (type) {
		return false;
	},

	getClassDef: function () {
		throw new Error("not supported");
	},

	toString: function () {
		return "void";
	}

});

var NullType = exports.NullType = Type.extend({

	isAssignable: function () {
		return false;
	},

	isConvertibleTo: function (type) {
		return type instanceof StringType || type instanceof ObjectType;
	},

	getClassDef: function () {
		throw new Error("not supported");
	},

	toString: function () {
		return "null";
	}

});

// primitive types

var PrimitiveType = exports.PrimitiveType = Type.extend({

	isAssignable: function () {
		return true; // still does not support "const" qualifier
	}

});

var BooleanType = exports.BooleanType = PrimitiveType.extend({

	$_classDef: null,

	isConvertibleTo: function (type) {
		return type instanceof BooleanType || type instanceof IntegerType || type instanceof NumberType;
	},

	getClassDef: function () {
		return BooleanType._classDef;
	},

	toString: function () {
		return "boolean";
	}

});

var IntegerType = exports.IntegerType = PrimitiveType.extend({

	$_classDef: null,

	isConvertibleTo: function (type) {
		return type instanceof IntegerType || type instanceof NumberType;
	},

	getClassDef: function () {
		return NumberType._classDef;
	},

	toString: function () {
		return "int";
	}

});

var NumberType = exports.NumberType = PrimitiveType.extend({

	$_classDef: null,

	isConvertibleTo: function (type) {
		return type instanceof IntegerType || type instanceof NumberType;
	},

	getClassDef: function () {
		return NumberType._classDef;
	},

	toString: function () {
		return "number";
	}

});

var StringType = exports.StringType = PrimitiveType.extend({

	$_classDef: null,

	isConvertibleTo: function (type) {
		if (type instanceof BooleanType)
			return true;
		if (type instanceof StringType)
			return true;
		return false;
	},

	getClassDef: function () {
		return StringType._classDef;
	},

	toString: function () {
		return "String";
	}

});

// array and hash type

var ArrayType = exports.ArrayType = Type.extend({

	initialize: function (elementType) {
		this._elementType = elementType;
	},

	isConvertibleTo: function (type) {
		if (type instanceof BooleanType)
			return true;
		if (type instanceof ArrayType && type._elementType.equals(this._elementType))
			return true;
		return false;
	},

	isAssignable: function () {
		return true; // still does not support "const" qualifier
	},
	
	getClassDef: function () {
		throw new Error("FIXME");
	},

	getElementType: function () {
		return this._elementType;
	},

	toString: function () {
		return this._elementType.toString() + "[]";
	}

});

var HashType = exports.HashType = Type.extend({

	initialize: function (elementType) {
		this._elementType = elementType;
	},

	isConvertibleTo: function (type) {
		if (type instanceof BooleanType)
			return true;
		if (type instanceof HashType && type._elementType.equals(this._elementType))
			return true;
		return false;
	},

	isAssignable: function () {
		return true; // still does not support "const" qualifier
	},
	
	getClassDef: function () {
		throw new Error("FIXME");
	},

	getElementType: function () {
		return this._elementType;
	},

	toString: function () {
		return "Hash<" + this._elementType.toString() + ">";
	}

});

// class and object types

var ClassDefType = exports.ClassDefType = Type.extend({

	initialize: function (classDef) {
		this._classDef = classDef;
	},

	isConvertibleTo: function (type) {
		return false;
	},

	isAssignable: function () {
		return false;
	},

	getClassDef: function () {
		return this._classDef;
	},

	toString: function () {
		return this._classDef.className();
	}

});

var ObjectType = exports.ObjectType = Type.extend({

	initialize: function () {
		switch (arguments.length) {
		case 1:
			this._classDef = arguments[0];
			this._className = this._classDef.className().toString();
			this._token = null;
			break;
		case 2:
			this._classDef = null;
			this._className = arguments[0];
			this._token = arguments[1];
			break;
		}
	},

	resolveType: function (errors, classDefs) {
		if (this._classDef == null) {
			if ((this._classDef = ClassDefinition.getClass(classDefs, this.toString())) == null) {
				errors.push(new CompileError(this._token, "'" + this.toString() + "' is not defined"));
			}
		}
	},

	isConvertibleTo: function (type) {
		if (type instanceof BooleanType)
			return true;
		if (! (type instanceof ObjectType))
			return false;
		return this._classDef.isConvertibleTo(type._classDef);
	},

	isAssignable: function () {
		return true; // still does not support "const" qualifier
	},

	getClassDef: function () {
		return this._classDef;
	},

	toString: function () {
		return this._className;
	}

});

// function types

var FunctionType = exports.FunctionType = Type.extend({
});

var FunctionChoiceType = exports.FunctionChoiceType = FunctionType.extend({

	initialize: function (types) {
		this._types = types;
	},

	isAssignable: function () {
		return false;
	},

	asAssignableType: function () {
		throw new Error("logic flaw");
	},

	getClassDef: function () {
		throw new Error("FIXME");
	},

	deduceByArgumentTypes: function (context, operatorToken, argTypes, isStatic) {
		// try an exact match
		for (var i = 0; i < this._types.length; ++i)
			if (this._types[i]._deduceByArgumentTypes(argTypes, isStatic, true))
				return this._types[i];
		// try loose match
		var matched = [];
		for (var i = 0; i < this._types.length; ++i)
			if (this._types[i]._deduceByArgumentTypes(argTypes, isStatic, false))
				matched.push(this._types[i]);
		switch (matched.length) {
		case 0:
			context.errors.push(new CompileError(operatorToken, "no function with matching arguments"));
			break;
		case 1:
			return matched[0];
		default:
			context.errors.push(new CompileError(operatorToken, "result of function resolution using the arguments is ambiguous"));
			break;
		}
		return null;
	},

	toString: function () {
		return this._types.length == 1 ? this._types[0].toString() : "<<multiple choices>>";
	}

});

var ResolvedFunctionType = exports.ResolvedFunctionType = FunctionType.extend({

	initialize: function (returnType, argTypes, isAssignable) {
		this._returnType = returnType;
		this._argTypes = argTypes;
		this._isAssignable = isAssignable;
	},

	setIsAssignable: function (isAssignable) {
		this._isAssignable = isAssignable;
		return this;
	},

	isAssignable: function () {
		return this._isAssignable;
	},

	asAssignableType: function () {
		return this._clone().setIsAssignable(true);
	},

	getClassDef: function () {
		throw new Error("FIXME");
	},

	getReturnType: function () {
		return this._returnType;
	},

	getArgumentTypes: function () {
		return this._argTypes;
	},

	deduceByArgumentTypes: function (context, operatorToken, argTypes, isStatic) {
		if (! this._deduceByArgumentTypes(argTypes, isStatic, false)) {
			context.errors.push(new CompileError(operatorToken, "no function with matching arguments:" + isStatic));
			return null;
		}
		return this;
	},

	_deduceByArgumentTypes: function (argTypes, isStatic, exact) {
		if ((this instanceof StaticFunctionType) != isStatic)
			return false;
		if (this._argTypes.length != argTypes.length)
			return false;
		for (var i = 0; i < argTypes.length; i++) {
			if (this._argTypes[i].equals(argTypes[i])) {
				// ok
			} else {
				if (exact)
					return false;
				if (! argTypes[i].isConvertibleTo(this._argTypes[i]))
					return false;
			}
		}
		return true;
	},

	toString: function () {
		var args = [];
		for (var i = 0; i < this._argTypes.length; ++i)
			args[i] = " : " + this._argTypes[i].toString();
		return this._toStringPrefix() + "function (" + args.join(", ") + ") : " + this._returnType.toString();
	}

});

var StaticFunctionType = exports.StaticFunctionType = ResolvedFunctionType.extend({

	initialize: function (returnType, argTypes, isAssignable) {
		ResolvedFunctionType.prototype.initialize.call(this, returnType, argTypes, isAssignable);
	},

	_clone: function () {
		return new StaticFunctionType(this._returnType, this._argTypes, this._isAssignable);
	},

	_toStringPrefix: function () {
		return "static ";
	}

});

var MemberFunctionType = exports.MemberFunctionType = ResolvedFunctionType.extend({

	initialize: function (objectType, returnType, argTypes, isAssignable) {
		ResolvedFunctionType.prototype.initialize.call(this, returnType, argTypes, isAssignable);
		this._objectType = objectType;
	},

	_clone: function () {
		return new MemberFunctionType(this._objectType, this._returnType, this._argTypes, this._isAssignable);
	},

	_toStringPrefix: function () {
		return this._objectType.toString() + ".";
	}

});

Type._initialize();

});require.register("util.js", function(module, exports, require, global){
"use strict";

var Class = require("./Class");

var CompileError = exports.CompileError = Class.extend({

	initialize: function () {
		switch (arguments.length) {
		case 2: // token, text
			this._filename = arguments[0].filename;
			this._pos = arguments[0].pos;
			this._message = arguments[1];
			break;
		case 3: // filename, pos, text
			this._filename = arguments[0];
			this._pos = arguments[1];
			this._message = arguments[2];
			break;
		default:
			throw new Error("Unrecognized arguments for CompileError: " + JSON.stringify( Array.prototype.slice.call(arguments) ));
		}
	},

	getFilename: function () {
		return this._filename;
	},

	getPosition: function () {
		return this._pos;
	},

	format: function (compiler) {
		var content  = compiler.getFileContent(this._filename);
		var lines    = content.split(/^/m); // TODO: cache it
		var position = new FilePos(lines, this._filename, this._pos);

		return "[" + position.toString() + "] " + this._message + "\n" + position.format();
	},

	toString: function () {
		return this._filename + "(" + this._pos + "):" +
			this._message;
	}

});

var Util = exports.Util = Class.extend({

	$serializeArray: function (a) {
		if (a == null)
			return null;
		var ret = [];
		for (var i = 0; i < a.length; ++i)
			ret[i] = a[i].serialize();
		return ret;
	},

	$serializeNullable: function (v) {
		if (v == null)
			return null;
		return v.serialize();
	},

	$repeat: function(c, n) {
		var s = "";
		for(var i = 0; i < n; ++i) {
			s += c;
		}
		return s;
	},

	$qualifiedNameToString: function (tokens) {
		var s = [];
		for (var i = 0; i < tokens.length; ++i)
			s[i] = tokens[i]._value;
		return s.join(".");
	}

});

var FilePos = exports.FilePos = Class.extend({
	$TAB_WIDTH: 4,
	
	initialize: function (lines, filename, pos) {
		this._filename = filename;
		
		var c   = 0;
		var row = 0;
		while(row < lines.length) {
			var lineLen = lines[row].length;
			if((c + lineLen) > pos) break;
			c += lineLen;

			++row;
		}
		
		this._lineNumber   = row + 1;
		this._columnNumber = pos - c;
		
		// adjust the visual width
		// TODO: support Unicode EAST ASIAN WIDTH characters
		//       see alco http://unicode.org/reports/tr11/
		var line = lines[row];

		if(line == null) { // EOF
			return;
		}

		var tabs = line.slice(0, this._columnNumber).match(/\t/g);
		if(tabs != null) {
			this._columnNumber += (FilePos.TAB_WIDTH-1) * tabs.length;
		}
		
		line = line.replace(/\t/, Util.repeat(" ", FilePos.TAB_WIDTH));

		this._line = line;
	},

	getLineNumber: function () {
		return this._lineNumber;
	},
	getColumnNumber: function () {
		return this._columnNumber;
	},
	
	format: function(size) {
		if(!size) size = 1;

		var s;
		if(this._line != null) {
			s = this._line.replace(/[\r\n]/, '') + "\n";

			s += Util.repeat(" ", this._columnNumber);
			s += Util.repeat("^", size);

			s += "\n";
		}
		else {
			s = "";
		}
		return s;
	},
	toString: function () {
		return this._filename + ':' + this._lineNumber;
	}
});

/*
var src = "foo\n\tbar\n\n\thello";
for(var i = 0; i < src.length; ++i) {
	var pos = new FilePos(src.split(/^/m), "foo.jsx", i);
	console.log(pos.explain());
}
//*/
// vim: set noexpandtab:

});require.register("validate.js", function(module, exports, require, global){
"use strict";

var inspect;
try {
    inspect = require("util").inspect; // on node
}
catch(e) {
    inspect = function(x) { return x };
}


function isa(expr, t) {
    if(expr == null) {
        throw new Error("Assertion failed: expected " +
                       t +
                       " but got " + inspect(expr));
    }
    if(typeof(t) === "string") {
        if(!(typeof(expr) === t)) {
            throw new Error("Assertion failed: " +
                            inspect(expr) +
                            " is not a type of " + t);
        }
    }
    else {
        if(!(expr instanceof t)) {
            throw new Error("Assertion failed: " +
                            inspect(expr) +
                            " is not an instance of " + t.name || t);
        }
    }
};

exports.isa = isa;


});compiler = require('compiler');
})();
